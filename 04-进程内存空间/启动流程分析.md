# Android启动流程中的进程空间演进

## 启动时序图

```
Bootloader → Kernel → Init → Zygote → System Server → App Process
    ↓         ↓       ↓       ↓           ↓            ↓
物理内存   虚拟内存  用户空间  进程模板   系统服务     应用进程
```

## 详细分析

### 阶段1: Bootloader - 物理内存初始化
- **内存检测**: 检测物理RAM大小和布局
- **内存映射**: 建立初始的物理地址映射
- **内存保留**: 为kernel预留内存空间

### 阶段2: Kernel启动 - 虚拟内存系统
- **MMU启用**: 开启内存管理单元
- **页表建立**: 创建虚拟地址到物理地址的映射
- **内存分区**: 划分kernel space和user space

### 阶段3: Init进程 - 第一个用户进程
- **进程空间创建**: 分配完整的4GB虚拟地址空间
- **ELF加载**: 加载init可执行文件到内存
- **栈和堆初始化**: 建立基本的运行环境

### 阶段4: Zygote进程 - 进程模板
- **预加载优化**: 
  - 加载核心系统类和资源
  - 预链接常用的native library
  - 建立共享的内存页面
- **进程模板化**: 成为所有应用进程的"模板"

### 阶段5: 应用进程Fork
- **Copy-On-Write机制**: 
  - 初始时共享Zygote的内存页面
  - 写操作时才复制页面
  - 大幅节省内存使用

## 关键概念对比

| 阶段 | 内存模型 | 地址空间 | 共享机制 |
|------|----------|----------|----------|
| Kernel | 物理直映 | 连续物理地址 | 无 |
| Init | 虚拟内存 | 独立4GB空间 | 无 |
| Zygote | 模板进程 | 预加载共享 | 只读共享 |
| App | Fork复制 | COW机制 | 写时复制 |

## 内存效率分析

### 传统模式 vs Zygote模式

**传统模式**:
```
Process A: [Kernel Space] + [独立用户空间100MB]
Process B: [Kernel Space] + [独立用户空间100MB]  
Process C: [Kernel Space] + [独立用户空间100MB]
总计: 300MB用户空间内存
```

**Zygote模式**:
```
Zygote:    [预加载50MB共享内容]
Process A: [共享50MB] + [私有30MB] = 80MB
Process B: [共享50MB] + [私有25MB] = 75MB  
Process C: [共享50MB] + [私有35MB] = 85MB
实际物理内存: 50MB + 30MB + 25MB + 35MB = 140MB
```

节省内存: (300MB - 140MB) / 300MB = 53%