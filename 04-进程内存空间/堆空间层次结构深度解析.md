# å †ç©ºé—´çš„ä¸‰å±‚ä¸–ç•Œï¼šç”¨Javaå¼€å‘è€…çš„è§†è§’ç†è§£

## æ¦‚è¿°ï¼šä¸ºä»€ä¹ˆè¦ç†è§£å †çš„å±‚æ¬¡ï¼Ÿ

ä½œä¸ºJavaå¼€å‘è€…ï¼Œå½“ä½ å†™ä¸‹ `val user = User()` æ—¶ï¼Œè¿™ä¸ªUserå¯¹è±¡åˆ°åº•å­˜åœ¨å“ªé‡Œï¼Ÿå¾ˆå¤šäººä¼šè¯´"å­˜åœ¨å †é‡Œ"ï¼Œä½†å®é™…ä¸ŠAndroidä¸­æœ‰**ä¸‰ä¸ªä¸åŒå±‚æ¬¡çš„å †**ï¼Œå°±åƒä¿„ç½—æ–¯å¥—å¨ƒä¸€æ ·å±‚å±‚åµŒå¥—ã€‚

## ğŸ¯ ç”¨ç†Ÿæ‚‰çš„æ¦‚å¿µç†è§£ï¼šå †å°±åƒåˆ†å±‚çš„æ•°æ®ç»“æ„

### æƒ³è±¡ä¸€ä¸ªæ™ºèƒ½çš„Mapç»“æ„
```kotlin
// æŠŠæ•´ä¸ªå†…å­˜ç³»ç»Ÿæƒ³è±¡æˆä¸€ä¸ªä¸‰å±‚çš„Mapç»“æ„
class AndroidMemorySystem {
    // ç¬¬3å±‚ï¼šä½ æœ€ç†Ÿæ‚‰çš„Javaå¯¹è±¡å­˜å‚¨
    private val javaObjectMap = mutableMapOf<String, Any>()
    
    // ç¬¬2å±‚ï¼šC++å¯¹è±¡å’ŒåŸç”Ÿå†…å­˜ç®¡ç†
    private val nativeMemoryMap = mutableMapOf<Long, ByteArray>()
    
    // ç¬¬1å±‚ï¼šæ“ä½œç³»ç»Ÿçš„è¿›ç¨‹å†…å­˜æ®µ
    private val processMemorySegments = mutableMapOf<String, MemorySegment>()
    
    fun createJavaObject(obj: Any): String {
        // Javaå¯¹è±¡åˆ›å»ºå®é™…ä¸Šæ˜¯ä¸‰å±‚æ“ä½œï¼š
        // 1. ARTè™šæ‹Ÿæœºåœ¨Javaå †ä¸­åˆ†é…
        val javaRef = javaObjectMap.put("obj_${obj.hashCode()}", obj)
        
        // 2. Javaå †æœ¬èº«æ˜¯ä»Nativeå †ç”³è¯·çš„å†…å­˜
        // 3. Nativeå †åˆæ˜¯è¿›ç¨‹å †æ®µçš„ä¸€éƒ¨åˆ†
        return "Javaå¯¹è±¡çš„ä¸‰å±‚åµŒå¥—å­˜å‚¨å®Œæˆ"
    }
}
```

## ç¬¬ä¸€å±‚ï¼šè¿›ç¨‹å †æ®µ - "åœŸåœ°"

### å°±åƒä¹°åœ°ç›–æˆ¿å­
```kotlin
// æ“ä½œç³»ç»Ÿç»™ä½ çš„Appåˆ†é…ä¸€å—"åœŸåœ°"
class ProcessHeapSegment {
    // è¿™æ˜¯Linuxå†…æ ¸åˆ†é…ç»™ä½ çš„è¿›ç¨‹çš„è™šæ‹Ÿå†…å­˜ç©ºé—´
    private var heapStart = 0x08048000L  // å †çš„èµ·å§‹åœ°å€
    private var currentBreak = heapStart  // å½“å‰å †çš„æœ«å°¾ï¼ˆbrkæŒ‡é’ˆï¼‰
    
    fun expandHeap(size: Long): Long {
        // å°±åƒå‘æ”¿åºœç”³è¯·æ‰©å¤§ä½ çš„åœŸåœ°è¾¹ç•Œ
        val oldBreak = currentBreak
        currentBreak += size
        
        // å®é™…è°ƒç”¨ç³»ç»Ÿè°ƒç”¨ brk() æˆ– mmap()
        return systemCall_brk(currentBreak)
    }
    
    // è¿™å—"åœŸåœ°"æ˜¯æ‰€æœ‰å†…å­˜åˆ†é…çš„åŸºç¡€
    // æ— è®ºæ˜¯Nativeå †è¿˜æ˜¯Javaå †ï¼Œéƒ½å¿…é¡»åœ¨è¿™å—åœŸåœ°ä¸Šå»ºè®¾
}

### ğŸ” ç”¨Memory Profilerè§‚å¯Ÿç¬¬ä¸€å±‚
```bash
# æŸ¥çœ‹è¿›ç¨‹çš„å †æ®µè¾¹ç•Œ
adb shell cat /proc/$(pidof com.yourapp)/maps | grep heap
# è¾“å‡ºç±»ä¼¼ï¼š08048000-20000000 rw-p heap
```

## ç¬¬äºŒå±‚ï¼šNativeå † - "å»ºç­‘å…¬å¸"

### å°±åƒä¸“ä¸šçš„å»ºç­‘æ‰¿åŒ…å•†
```kotlin
// Nativeå †ç®¡ç†å™¨å°±åƒä¸€ä¸ªä¸“ä¸šçš„å»ºç­‘æ‰¿åŒ…å•†
class NativeHeapManager {
    // ä»è¿›ç¨‹å †æ®µ(åœŸåœ°)ä¸­ç”³è¯·åŸææ–™
    private val rawMemoryFromOS = mutableMapOf<Long, ByteArray>()
    
    // æä¾›å„ç§è§„æ ¼çš„"æˆ¿é—´"ç»™ä¸åŒå®¢æˆ·
    fun malloc(size: Int): Long {
        // å°±åƒæ‰¿åŒ…å•†æ ¹æ®éœ€æ±‚å»ºé€ ä¸åŒå¤§å°çš„æˆ¿é—´
        return when (size) {
            in 1..32 -> allocateSmallBlock(size)      // å°æˆ·å‹
            in 33..1024 -> allocateMediumBlock(size)  // ä¸­æˆ·å‹
            else -> allocateLargeBlock(size)          // å¤§æˆ·å‹
        }
    }
    
    fun free(address: Long) {
        // å›æ”¶æˆ¿é—´ï¼Œé‡æ–°è£…ä¿®åå†ç§Ÿç»™å…¶ä»–å®¢æˆ·
        recycleBlock(address)
    }
    
    // Android 8+: ä¸“é—¨ä¸ºå›¾ç‰‡åƒç´ æ•°æ®å»ºé€ çš„"å›¾ç‰‡ä»“åº“"
    fun allocateBitmapPixels(width: Int, height: Int): Long {
        val pixelSize = width * height * 4  // ARGB
        return malloc(pixelSize)  // ç›´æ¥åœ¨Nativeå †åˆ†é…
    }
}
```

### Nativeå †çš„å®é™…ä½¿ç”¨åœºæ™¯
```kotlin
// JNIå¼€å‘ä¸­ä½ ä¼šç›´æ¥æ¥è§¦åˆ°Nativeå †
external fun nativeAllocateBuffer(size: Int): Long
external fun nativeFreeBuffer(buffer: Long)

class ImageProcessor {
    fun processLargeImage(imagePath: String) {
        // 1. åœ¨Nativeå †ä¸­åˆ†é…å›¾åƒå¤„ç†ç¼“å†²åŒº
        val bufferSize = 1920 * 1080 * 4  // 4Kå›¾åƒ
        val nativeBuffer = nativeAllocateBuffer(bufferSize)
        
        try {
            // 2. å›¾åƒå¤„ç†æ“ä½œï¼ˆåœ¨Nativeä»£ç ä¸­æ‰§è¡Œï¼‰
            processImageInNative(imagePath, nativeBuffer)
            
            // 3. ç»“æœä¼ å›Javaå±‚
            val result = getProcessedImage(nativeBuffer)
            
        } finally {
            // 4. åŠæ—¶é‡Šæ”¾Nativeå†…å­˜ï¼ˆæ²¡æœ‰GCè‡ªåŠ¨ç®¡ç†ï¼‰
            nativeFreeBuffer(nativeBuffer)
        }
    }
}
```

## ç¬¬ä¸‰å±‚ï¼šART Javaå † - "é«˜ç«¯ä½å®…åŒº"

### å°±åƒåŸºäºå»ºç­‘çš„é«˜ç«¯ç‰©ä¸šç®¡ç†
```kotlin
// ARTè™šæ‹Ÿæœºå°±åƒä¸€ä¸ªé«˜ç«¯ä½å®…åŒºçš„ç‰©ä¸šç®¡ç†å…¬å¸
class ARTHeapManager {
    // ä»Nativeå †(å»ºç­‘æ‰¿åŒ…å•†)ç§Ÿä¸‹ä¸€æ•´å—åŒºåŸŸ
    private var totalHeapMemory: Long = 0
    private var usedHeapMemory: Long = 0
    
    // æŒ‰ç…§Javaå¯¹è±¡çš„ç‰¹ç‚¹è¿›è¡Œç²¾ç»†åŒ–ç®¡ç†
    private val youngGeneration = mutableListOf<JavaObject>()  // æ–°ä½æˆ·
    private val oldGeneration = mutableListOf<JavaObject>()    // è€ä½æˆ·
    
    fun allocateObject(obj: Any): JavaObject {
        // å°±åƒç‰©ä¸šå…¬å¸ä¸ºæ–°ä½æˆ·åˆ†é…æˆ¿é—´
        val javaObj = JavaObject(obj)
        
        // æ–°å¯¹è±¡å…ˆä½åœ¨"é’å¹´å…¬å¯“"
        youngGeneration.add(javaObj)
        usedHeapMemory += javaObj.size
        
        // å¦‚æœå†…å­˜ä¸å¤Ÿäº†ï¼Œå¯åŠ¨"æ¬è¿è®¡åˆ’"(GC)
        if (usedHeapMemory > totalHeapMemory * 0.8) {
            performGarbageCollection()
        }
        
        return javaObj
    }
    
    private fun performGarbageCollection() {
        // ç‰©ä¸šå…¬å¸çš„å®šæœŸæ¬è¿å’Œæ¸…ç†å·¥ä½œ
        // 1. æ¸…ç†æ²¡äººä½¿ç”¨çš„å¯¹è±¡(åƒåœ¾å›æ”¶)
        // 2. å°†é•¿æœŸä½æˆ·æ¬åˆ°"é•¿æœŸå…¬å¯“"(Old Generation)
        // 3. ä¸ºæ–°ä½æˆ·è…¾å‡ºç©ºé—´
        
        Log.d("ART_GC", "å¼€å§‹åƒåœ¾å›æ”¶ï¼Œé‡Šæ”¾${cleanupUnusedObjects()}KBå†…å­˜")
    }
}

data class JavaObject(val obj: Any, val size: Long = estimateSize(obj))
```

### ARTå †çš„åˆ†ä»£ç®¡ç†ï¼šå°±åƒå°åŒºçš„æ¥¼å±‚è§„åˆ’
```kotlin
// ARTå †å°±åƒä¸€ä¸ªæŒ‰å¹´é¾„åˆ†å±‚çš„é«˜ç«¯å°åŒº
class GenerationalHeapLayout {
    
    // 1å±‚ï¼šæ–°ç”Ÿä»£(Young Generation) - æ–°ä¸šä¸»
    class YoungGeneration {
        val eden = mutableListOf<Any>()        // åˆšæ¬å…¥çš„æ–°ä¸šä¸»
        val survivor1 = mutableListOf<Any>()   // ç»å†è¿‡ä¸€æ¬¡æ¬è¿çš„ä¸šä¸»  
        val survivor2 = mutableListOf<Any>()   // ç»å†è¿‡ä¸¤æ¬¡æ¬è¿çš„ä¸šä¸»
        
        fun allocateNewObject(obj: Any) {
            eden.add(obj)  // æ–°å¯¹è±¡æ€»æ˜¯å…ˆåˆ†é…åˆ°EdenåŒº
        }
    }
    
    // 2å±‚ï¼šè€ç”Ÿä»£(Old Generation) - é•¿æœŸä¸šä¸»
    class OldGeneration {
        val tenured = mutableListOf<Any>()     // é•¿æœŸç¨³å®šçš„è€ä¸šä¸»
        
        fun promoteFromYoung(obj: Any) {
            tenured.add(obj)  // ä»å¹´è½»ä»£æ™‹å‡çš„å¯¹è±¡
        }
    }
    
    // 3å±‚ï¼šå¤§å¯¹è±¡åŒº - ç‰¹æ®Šä½æˆ·(å¤§æˆ·å‹)
    class LargeObjectSpace {
        val largeObjects = mutableMapOf<String, Any>()
        
        fun allocateLargeObject(obj: Any) {
            // å¤§å¯¹è±¡ç›´æ¥åˆ†é…ï¼Œä¸ç»è¿‡å¹´è½»ä»£
            largeObjects[obj.toString()] = obj
        }
    }
}
```

## ğŸ”¬ å®æˆ˜éªŒè¯ï¼šè§‚å¯Ÿä¸‰å±‚å †çš„å·¥ä½œ

### ç”¨ä»£ç éªŒè¯ä¸‰å±‚å †çš„å­˜åœ¨
```kotlin
class HeapLayerExplorer : AppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        demonstrateThreeHeapLayers()
    }
    
    private fun demonstrateThreeHeapLayers() {
        val memInfo = Debug.MemoryInfo()
        
        // ç¬¬3å±‚ï¼šè§‚å¯ŸART Javaå †
        val beforeJavaHeap = Runtime.getRuntime().totalMemory()
        val javaObjects = Array(1000) { User("User$it") }
        val afterJavaHeap = Runtime.getRuntime().totalMemory()
        Log.d("Heap3", "ART Javaå †å¢é•¿: ${(afterJavaHeap - beforeJavaHeap) / 1024}KB")
        
        // ç¬¬2å±‚ï¼šè§‚å¯ŸNativeå †ï¼ˆé€šè¿‡Bitmapåƒç´ ï¼‰
        Debug.getMemoryInfo(memInfo)
        val beforeNativeHeap = memInfo.nativeHeap
        val bitmap = BitmapFactory.decodeResource(resources, R.drawable.large_image)
        Debug.getMemoryInfo(memInfo)
        val afterNativeHeap = memInfo.nativeHeap
        Log.d("Heap2", "Nativeå †å¢é•¿: ${afterNativeHeap - beforeNativeHeap}KB")
        
        // ç¬¬1å±‚ï¼šè§‚å¯Ÿè¿›ç¨‹æ€»å†…å­˜
        val beforeTotal = memInfo.totalPss
        // åˆ›å»ºå¤§é‡å¯¹è±¡è§¦å‘è¿›ç¨‹å †æ®µæ‰©å±•
        createMixedObjects()
        Debug.getMemoryInfo(memInfo)
        val afterTotal = memInfo.totalPss
        Log.d("Heap1", "è¿›ç¨‹æ€»å†…å­˜å¢é•¿: ${afterTotal - beforeTotal}KB")
    }
    
    private fun createMixedObjects() {
        // æ··åˆåˆ›å»ºJavaå¯¹è±¡å’ŒNativeå¯¹è±¡
        val javaList = mutableListOf<Any>()
        repeat(500) {
            javaList.add(User("Mixed$it"))
            // åŒæ—¶åˆ›å»ºä¸€äº›Bitmapè§¦å‘Nativeåˆ†é…
            if (it % 10 == 0) {
                val smallBitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888)
                javaList.add(smallBitmap)
            }
        }
    }
}
```

## Android 8çš„å…³é”®å˜åŒ–ï¼šå›¾ç‰‡åƒç´ æ•°æ®çš„æ¬å®¶

### æ¬å®¶å‰ï¼šåƒç´ æ•°æ®ä½åœ¨"é«˜ç«¯å°åŒº"
```kotlin
// Android 7åŠä¹‹å‰ï¼šå›¾ç‰‡åƒç´ æ•°æ®å­˜åœ¨ART Javaå †ä¸­
class BitmapBeforeAndroid8 {
    fun loadImage(): Bitmap {
        val bitmap = BitmapFactory.decodeResource(resources, R.drawable.image)
        
        // åƒç´ æ•°æ®çš„å­˜å‚¨ä½ç½®ï¼š
        // è¿›ç¨‹å †æ®µ â†’ Nativeå † â†’ ART Javaå † â†’ åƒç´ æ•°ç»„
        
        // é—®é¢˜ï¼šå ç”¨Javaå †ç©ºé—´ï¼Œå®¹æ˜“è§¦å‘GC
        return bitmap
    }
}
```

### æ¬å®¶åï¼šåƒç´ æ•°æ®ä½åœ¨"ç»æµé€‚ç”¨æˆ¿"
```kotlin  
// Android 8+ï¼šå›¾ç‰‡åƒç´ æ•°æ®ç›´æ¥å­˜åœ¨Nativeå †ä¸­
class BitmapAfterAndroid8 {
    fun loadImage(): Bitmap {
        val bitmap = BitmapFactory.decodeResource(resources, R.drawable.image)
        
        // åƒç´ æ•°æ®çš„æ–°å­˜å‚¨ä½ç½®ï¼š
        // è¿›ç¨‹å †æ®µ â†’ Nativeå † â†’ åƒç´ æ•°æ®
        // Bitmap Javaå¯¹è±¡ï¼šè¿›ç¨‹å †æ®µ â†’ Nativeå † â†’ ART Javaå † â†’ Bitmapå®ä¾‹
        
        // ä¼˜ç‚¹ï¼šå‡å°‘Javaå †å‹åŠ›ï¼ŒGCæ›´é«˜æ•ˆ
        return bitmap
    }
}
```

### ğŸ” ç”¨Memory Profilerè§‚å¯Ÿè¿™ä¸ªå˜åŒ–
```kotlin
fun compareBitmapMemoryLocation() {
    val memBefore = Debug.MemoryInfo()
    Debug.getMemoryInfo(memBefore)
    
    val largeBitmap = BitmapFactory.decodeResource(resources, R.drawable.large_image)
    
    val memAfter = Debug.MemoryInfo()
    Debug.getMemoryInfo(memAfter)
    
    // Android 7ç»“æœï¼šdalvikHeap æ˜¾è‘—å¢é•¿
    // Android 8+ç»“æœï¼šnativeHeap æ˜¾è‘—å¢é•¿
    Log.d("BitmapMemory", """
        Javaå †å˜åŒ–: ${memAfter.dalvikHeap - memBefore.dalvikHeap}KB
        Nativeå †å˜åŒ–: ${memAfter.nativeHeap - memBefore.nativeHeap}KB
    """.trimIndent())
}
```

é€šè¿‡è¿™ç§Javaå¼€å‘è€…ç†Ÿæ‚‰çš„ç±»æ¯”å’Œå®é™…ä»£ç éªŒè¯ï¼Œä½ å¯ä»¥æ·±å…¥ç†è§£Androidå†…å­˜ç®¡ç†çš„ä¸‰å±‚æ¶æ„ï¼Œä»¥åŠä¸ºä»€ä¹ˆAndroid 8è¦å°†å›¾ç‰‡å†…å­˜ä»Javaå †æ¬åˆ°Nativeå †ã€‚

## Zygoteå¯åŠ¨è¿‡ç¨‹ä¸­çš„å †ç©ºé—´åˆ›å»º

### è¯¦ç»†å¯åŠ¨åºåˆ—

#### ç¬¬1é˜¶æ®µï¼šè¿›ç¨‹ç©ºé—´åˆå§‹åŒ–
```cpp
// Initè¿›ç¨‹é€šè¿‡fork/execå¯åŠ¨Zygote
pid_t zygote_pid = fork();
if (zygote_pid == 0) {
    // å­è¿›ç¨‹ï¼šZygote
    // Linuxå†…æ ¸ä¸ºæ–°è¿›ç¨‹åˆ†é…è™šæ‹Ÿåœ°å€ç©ºé—´ï¼ŒåŒ…æ‹¬å †æ®µ
    exec("/system/bin/app_process", "zygote", ...);
}
```

#### ç¬¬2é˜¶æ®µï¼šC++è¿è¡Œæ—¶åˆå§‹åŒ–
```cpp  
// app_processå¯åŠ¨ï¼ŒC++è¿è¡Œæ—¶åˆå§‹åŒ–
int main(int argc, char* argv[]) {
    // C++è¿è¡Œæ—¶åº“åˆå§‹åŒ–Nativeå †ç®¡ç†å™¨
    malloc_init();  // åˆå§‹åŒ–jemallocæˆ–å…¶ä»–åˆ†é…å™¨
    
    // æ­¤æ—¶Nativeå †å°±ç»ªï¼Œå¯ä»¥ä½¿ç”¨malloc/free
    void* test = malloc(100);  // åœ¨è¿›ç¨‹å †æ®µä¸­åˆ†é…å†…å­˜
}
```

#### ç¬¬3é˜¶æ®µï¼šARTè™šæ‹Ÿæœºå †åˆå§‹åŒ–
```cpp
// AndroidRuntimeå¯åŠ¨ARTè™šæ‹Ÿæœº
void AndroidRuntime::start() {
    // åˆ›å»ºARTè™šæ‹Ÿæœºå®ä¾‹
    JavaVMInitArgs initArgs;
    
    // é…ç½®å †å‚æ•°
    addOption("-Xms64m");           // åˆå§‹å †å¤§å°
    addOption("-Xmx512m");          // æœ€å¤§å †å¤§å°  
    addOption("-XX:HeapGrowthLimit=384m");
    
    // å¯åŠ¨è™šæ‹Ÿæœºï¼Œå†…éƒ¨ä¼šåˆ†é…å †ç©ºé—´
    JNI_CreateJavaVM(&javaVM, &env, &initArgs);
}

// ARTè™šæ‹Ÿæœºå†…éƒ¨å®ç°
JavaVMExt* Runtime::Create() {
    // ä»Nativeå †ç”³è¯·å†…å­˜ç»™ARTå †
    size_t heap_size = options.GetHeapMaxSize();
    void* heap_base = malloc(heap_size);  // â† å…³é”®ï¼šä½¿ç”¨malloc
    
    // åŸºäºç”³è¯·çš„å†…å­˜åˆ›å»ºARTå †ç®¡ç†å™¨
    heap_ = new Heap(heap_base, heap_size, /*...å…¶ä»–å‚æ•°...*/);
    
    return new JavaVMExt(this, options);
}
```

#### ç¬¬4é˜¶æ®µï¼šJavaå¯¹è±¡ç©ºé—´å‡†å¤‡å°±ç»ª
```java
// Zygote.java 
public static void main(String argv[]) {
    // æ­¤æ—¶ä¸‰å±‚å †ç»“æ„éƒ½å·²å°±ç»ªï¼š
    // 1. è¿›ç¨‹å †æ®µ (Linuxå†…æ ¸åˆ†é…)
    // 2. Nativeå † (jemallocç®¡ç†)  
    // 3. ART Javaå † (ARTè™šæ‹Ÿæœºç®¡ç†ï¼ŒåŸºäºNativeå †ç”³è¯·çš„å†…å­˜)
    
    preloadClasses();  // é¢„åŠ è½½ç³»ç»Ÿç±»åˆ°ARTå †
    preloadResources(); // é¢„åŠ è½½èµ„æº
}
```

### å†…å­˜æ‰€æœ‰æƒå’Œç®¡ç†è¾¹ç•Œ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                Linux Kernel                     â”‚
â”‚  ç®¡ç†è¿›ç¨‹è™šæ‹Ÿåœ°å€ç©ºé—´ï¼ŒåŒ…æ‹¬å †æ®µçš„æ‰©å±•å’Œæ˜ å°„        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â†‘ brk()/mmap()
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            Native Heap Allocator                â”‚  
â”‚     (jemalloc/dlmalloc)                        â”‚
â”‚  ç®¡ç†è¿›ç¨‹å †æ®µå†…çš„å†…å­˜å—åˆ†é…å’Œé‡Šæ”¾                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â†‘ malloc()/free()
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            ART Virtual Machine                  â”‚
â”‚  ç®¡ç†ä»Nativeå †ç”³è¯·çš„å¤§å—å†…å­˜ï¼Œå®ç°Javaå¯¹è±¡åˆ†é…   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â†‘ new Object()
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Java Application                   â”‚
â”‚           å¼€å‘è€…ç¼–å†™çš„Java/Kotlinä»£ç             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Android 8 å›¾ç‰‡å†…å­˜å˜åŒ–çš„æ·±å±‚åŸç†

### å˜åŒ–å‰ï¼šå›¾ç‰‡åƒç´ æ•°æ®çš„å†…å­˜è·¯å¾„

```
ç”¨æˆ·è°ƒç”¨: BitmapFactory.decodeResource()
    â†“
JNIè°ƒç”¨: BitmapFactory_nativeDecodeResource()  
    â†“
Skiaè§£ç : SkCodec::getPixels() 
    â†“
ARTåˆ†é…: åœ¨ARTå †ä¸­åˆ†é…åƒç´ æ•°ç»„
    â†“  
å†…å­˜ä½ç½®: è¿›ç¨‹å †æ®µ â†’ Nativeå † â†’ ARTå † â†’ åƒç´ æ•°ç»„
```

**å†…å­˜å…³ç³»**ï¼š
```
Process Heap Segment
â””â”€â”€ Native Heap (jemalloc)
    â””â”€â”€ ART Heap (ä»Nativeå †ç”³è¯·çš„å¤§å—å†…å­˜)
        â”œâ”€â”€ Javaå¯¹è±¡ (Bitmapå®ä¾‹)
        â””â”€â”€ åƒç´ æ•°æ® (ARGBæ•°ç»„) â† Android 7åŠä¹‹å‰
```

### å˜åŒ–åï¼šå›¾ç‰‡åƒç´ æ•°æ®çš„æ–°è·¯å¾„

```  
ç”¨æˆ·è°ƒç”¨: BitmapFactory.decodeResource()
    â†“
JNIè°ƒç”¨: BitmapFactory_nativeDecodeResource()
    â†“  
Skiaè§£ç : SkCodec::getPixels()
    â†“
ç›´æ¥åˆ†é…: malloc() åœ¨Nativeå †ä¸­åˆ†é…
    â†“
å†…å­˜ä½ç½®: è¿›ç¨‹å †æ®µ â†’ Nativeå † â†’ åƒç´ æ•°ç»„
```

**æ–°çš„å†…å­˜å…³ç³»**ï¼š
```
Process Heap Segment  
â””â”€â”€ Native Heap (jemalloc)
    â”œâ”€â”€ ART Heap (ä»Nativeå †ç”³è¯·çš„å¤§å—å†…å­˜)
    â”‚   â””â”€â”€ Javaå¯¹è±¡ (Bitmapå®ä¾‹ï¼Œåªå«å…ƒæ•°æ®)
    â””â”€â”€ åƒç´ æ•°æ® (ARGBæ•°ç»„) â† Android 8+ ç›´æ¥åœ¨è¿™é‡Œ
```

## å®é™…æµ‹é‡å’ŒéªŒè¯

### æŸ¥çœ‹å †ç©ºé—´çš„å·¥å…·å‘½ä»¤

#### 1. æŸ¥çœ‹è¿›ç¨‹æ•´ä½“å†…å­˜å¸ƒå±€
```bash
# æŸ¥çœ‹è¿›ç¨‹çš„å†…å­˜æ®µåˆ†å¸ƒ
adb shell cat /proc/$(pidof com.example.app)/maps | grep heap
```

#### 2. æŸ¥çœ‹Nativeå †ä½¿ç”¨æƒ…å†µ  
```bash
# æŸ¥çœ‹è¯¦ç»†å†…å­˜ä¿¡æ¯
adb shell dumpsys meminfo com.example.app
```

è¾“å‡ºç¤ºä¾‹ï¼š
```
** MEMINFO in pid 12345 [com.example.app] **
                   Pss  Private  Private  SwapPss     Heap     Heap     Heap
                 Total    Dirty    Clean    Dirty     Size    Alloc     Free
                ------   ------   ------   ------   ------   ------   ------
  Java Heap:     8924     8884        0        0    20480    12345     8135
  Native Heap:   15678    15200        0        0                           
  Code:          4562        0     4562        0                           
  Stack:         1024     1024        0        0                           
  Graphics:      25600    25600        0        0                           
  Private Other: 8234     8000      234        0
  System:        2345        0     2345        0
               ------   ------   ------   ------   ------   ------   ------
  TOTAL:        66367    58708     7141        0    20480    12345     8135
```

**å…³é”®æŒ‡æ ‡è¯´æ˜**ï¼š
- **Java Heap**: ARTè™šæ‹Ÿæœºå †çš„ä½¿ç”¨æƒ…å†µ
- **Native Heap**: C/C++å †çš„ä½¿ç”¨æƒ…å†µï¼ŒAndroid 8+åŒ…å«å›¾ç‰‡åƒç´ æ•°æ®
- **Graphics**: GPUç›¸å…³å†…å­˜ï¼ŒåŒ…å«çº¹ç†ç­‰

#### 3. è¿è¡Œæ—¶éªŒè¯å†…å­˜åˆ†é…ä½ç½®
```kotlin
// æµ‹è¯•ä»£ç ï¼šåŠ è½½å¤§å›¾ç‰‡è§‚å¯Ÿå†…å­˜å˜åŒ–
fun testBitmapMemoryLocation() {
    val memBefore = Debug.MemoryInfo()
    Debug.getMemoryInfo(memBefore)
    
    val largeBitmap = BitmapFactory.decodeResource(resources, R.drawable.large_image)
    
    val memAfter = Debug.MemoryInfo()  
    Debug.getMemoryInfo(memAfter)
    
    Log.d("Memory", "Java Heapå¢é•¿: ${memAfter.dalvikHeap - memBefore.dalvikHeap}KB")
    Log.d("Memory", "Native Heapå¢é•¿: ${memAfter.nativeHeap - memBefore.nativeHeap}KB")
}
```

**Android 7ç»“æœ**ï¼šJava Heapå¢é•¿æ˜¾è‘—
**Android 8+ç»“æœ**ï¼šNative Heapå¢é•¿æ˜¾è‘—

## è¿›ç¨‹ç©ºé—´å…¨æ™¯ï¼šè™šæ‹Ÿåœ°å€ç©ºé—´çš„å®Œæ•´å¸ƒå±€

### è¿›ç¨‹ç©ºé—´å°±åƒä¸€ä¸ªå®Œæ•´çš„åŠå…¬å¤§æ¥¼

```
è™šæ‹Ÿåœ°å€ç©ºé—´å¸ƒå±€ (32ä½è¿›ç¨‹ç¤ºä¾‹):

0xFFFFFFFF  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚          å†…æ ¸ç©ºé—´              â”‚  â† åº”ç”¨æ— æ³•ç›´æ¥è®¿é—®
            â”‚    (Kernel Virtual Memory)     â”‚
0xC0000000  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â† ç”¨æˆ·ç©ºé—´è¾¹ç•Œ
            â”‚            æ ˆåŒº                 â”‚  â† Java/Nativeæ–¹æ³•è°ƒç”¨æ ˆ
            â”‚           (Stack)               â”‚    å‘ä¸‹å¢é•¿ â†“
            â”‚              â†“                  â”‚
            â”‚                                â”‚
            â”‚           ç©ºé—²åŒºåŸŸ              â”‚  â† æ ˆå †ä¹‹é—´çš„å®‰å…¨ç¼“å†²åŒº
            â”‚                                â”‚
            â”‚              â†‘                  â”‚
            â”‚             å †åŒº                â”‚  â† åŠ¨æ€å†…å­˜åˆ†é…åŒºåŸŸ
            â”‚            (Heap)               â”‚    å‘ä¸Šå¢é•¿ â†‘
0x08048000  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â† å †çš„èµ·å§‹ä½ç½®
            â”‚            æ•°æ®æ®µ               â”‚  â† å…¨å±€å˜é‡ã€é™æ€å˜é‡
            â”‚           (Data)                â”‚
            â”‚            BSSæ®µ                â”‚  â† æœªåˆå§‹åŒ–å…¨å±€å˜é‡
            â”‚           å¸¸é‡æ®µ                â”‚  â† å­—ç¬¦ä¸²å¸¸é‡ç­‰
            â”‚            ä»£ç æ®µ               â”‚  â† ç¨‹åºæœºå™¨ç 
            â”‚           (Text)                â”‚
0x00000000  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å®é™…éªŒè¯ï¼šæŸ¥çœ‹ä½ çš„Appè¿›ç¨‹ç©ºé—´å¸ƒå±€

```kotlin
class ProcessMemoryExplorer {
    fun exploreProcessLayout() {
        // è·å–å½“å‰è¿›ç¨‹ID
        val pid = android.os.Process.myPid()
        Log.d("ProcessMemory", "å½“å‰è¿›ç¨‹PID: $pid")
        
        // é€šè¿‡ADBå‘½ä»¤æŸ¥çœ‹è¿›ç¨‹å†…å­˜æ˜ å°„
        // adb shell cat /proc/$pid/maps
        
        exploitMemoryRegions()
    }
    
    private fun exploreMemoryRegions() {
        val memInfo = Debug.MemoryInfo()
        Debug.getMemoryInfo(memInfo)
        
        Log.d("Memory", """
            è¿›ç¨‹å†…å­˜å„åŒºåŸŸä½¿ç”¨æƒ…å†µ:
            Javaå †: ${memInfo.dalvikHeap}KB
            Nativeå †: ${memInfo.nativeHeap}KB  
            ä»£ç æ®µ: ${memInfo.code}KB
            æ ˆç©ºé—´: ${memInfo.stack}KB
            å›¾å½¢å†…å­˜: ${memInfo.graphics}KB
            å…¶ä»–ç§æœ‰å†…å­˜: ${memInfo.privateOther}KB
            ç³»ç»Ÿå†…å­˜: ${memInfo.system}KB
            æ€»è®¡: ${memInfo.totalPss}KB
        """.trimIndent())
    }
}
```

## Zygoteè¿›ç¨‹å·¥å‚ï¼šCopy-On-Writeçš„å†…å­˜ä¼˜åŒ–è‰ºæœ¯

### Zygoteå°±åƒä¸€ä¸ªåº”ç”¨ç¨‹åºçš„"ç”Ÿäº§å·¥å‚"

```kotlin
// æƒ³è±¡Zygoteå°±åƒä¸€ä¸ªæ±½è½¦ç”Ÿäº§çº¿
class ZygoteProcessFactory {
    
    // "åŸå‹è½¦"ï¼šé¢„è£…äº†Android Frameworkçš„è¿›ç¨‹æ¨¡æ¿
    private val prototypeProcess = ProcessTemplate().apply {
        preloadSystemClasses()     // é¢„è£…ç³»ç»Ÿç±»åº“
        preloadResources()        // é¢„è£…å…±äº«èµ„æº
        initializeART()          // åˆå§‹åŒ–ARTè™šæ‹Ÿæœº
    }
    
    // ç”Ÿäº§æ–°çš„Appè¿›ç¨‹
    fun forkAppProcess(packageName: String): Process {
        // å…³é”®ï¼šä½¿ç”¨fork()åˆ›å»ºè¿›ç¨‹å‰¯æœ¬
        val newProcess = fork(prototypeProcess)  // Linuxç³»ç»Ÿè°ƒç”¨
        
        // Copy-On-Writeé­”æ³•:
        // 1. æ–°è¿›ç¨‹ä¸Zygoteå…±äº«ç›¸åŒçš„å†…å­˜é¡µ
        // 2. åªæœ‰å½“ä¿®æ”¹å†…å­˜æ—¶æ‰çœŸæ­£å¤åˆ¶
        // 3. å¤§é‡èŠ‚çœå†…å­˜å’Œå¯åŠ¨æ—¶é—´
        
        return newProcess.apply {
            customizeForApp(packageName)  // ä¸ªæ€§åŒ–é…ç½®
        }
    }
}
```

### Copy-On-Writeæœºåˆ¶çš„æ·±å…¥ç†è§£

```kotlin
class CopyOnWriteDemo {
    
    fun demonstrateCOW() {
        // åœºæ™¯ï¼šZygoteè¿›ç¨‹æœ‰ä¸€ä¸ªå¤§çš„é¢„åŠ è½½ç±»æ•°ç»„
        val preloadedClasses = Array(10000) { SystemClass("Class$it") }
        
        // å½“fork()åˆ›å»ºæ–°è¿›ç¨‹æ—¶ï¼š
        // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        // â”‚  Zygote Process â”‚    â”‚   App Process   â”‚
        // â”‚                 â”‚    â”‚                 â”‚  
        // â”‚ preloadedClassesâ”œâ”€â”€â”€â–¶â”‚ preloadedClassesâ”‚ â† å…±äº«åŒä¸€ç‰©ç†å†…å­˜é¡µ
        // â”‚                 â”‚    â”‚                 â”‚
        // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        
        // åªæœ‰å½“Appè¿›ç¨‹ä¿®æ”¹è¿™äº›ç±»æ—¶ï¼Œæ‰ä¼šè§¦å‘é¡µé¢å¤åˆ¶
        modifyClassInAppProcess(preloadedClasses[0])  // è¿™æ—¶æ‰çœŸæ­£å¤åˆ¶å†…å­˜é¡µ
    }
    
    private fun modifyClassInAppProcess(systemClass: SystemClass) {
        // ä¿®æ”¹æ“ä½œè§¦å‘COWï¼Œå†…å­˜é¡µè¢«å¤åˆ¶
        systemClass.customProperty = "App specific data"
    }
}
```

### å®é™…æµ‹é‡COWæ•ˆæœ

```bash
# æŸ¥çœ‹è¿›ç¨‹é—´å…±äº«å†…å­˜æƒ…å†µ
adb shell cat /proc/$(pidof zygote)/smaps | grep -E "(Shared|Private)"
adb shell cat /proc/$(pidof com.yourapp)/smaps | grep -E "(Shared|Private)"

# è¾“å‡ºç¤ºä¾‹ï¼š
# Shared_Clean:     128000 kB  â† ä¸å…¶ä»–è¿›ç¨‹å…±äº«çš„å¹²å‡€å†…å­˜é¡µ
# Shared_Dirty:       4000 kB  â† ä¸å…¶ä»–è¿›ç¨‹å…±äº«çš„è„å†…å­˜é¡µ  
# Private_Clean:     32000 kB  â† è¿›ç¨‹ç§æœ‰çš„å¹²å‡€å†…å­˜é¡µ
# Private_Dirty:     16000 kB  â† è¿›ç¨‹ç§æœ‰çš„è„å†…å­˜é¡µ
```

## çº¿ç¨‹æ ˆçš„ç‰¹æ®Šæ€§ï¼šä¸»çº¿ç¨‹ vs æ™®é€šçº¿ç¨‹

### ä¸»çº¿ç¨‹ï¼šä½¿ç”¨è¿›ç¨‹åŸå§‹æ ˆç©ºé—´

```kotlin
class MainThreadStackAnalysis {
    
    fun analyzeMainThreadStack() {
        // ä¸»çº¿ç¨‹ä½¿ç”¨è¿›ç¨‹åˆ›å»ºæ—¶åˆ†é…çš„åŸå§‹æ ˆç©ºé—´
        if (Looper.myLooper() == Looper.getMainLooper()) {
            Log.d("Stack", "è¿è¡Œåœ¨ä¸»çº¿ç¨‹ï¼Œä½¿ç”¨è¿›ç¨‹åŸå§‹æ ˆç©ºé—´")
            
            // ä¸»çº¿ç¨‹æ ˆçš„ç‰¹ç‚¹ï¼š
            // 1. ä½ç½®å›ºå®šï¼šé€šå¸¸åœ¨è™šæ‹Ÿåœ°å€ç©ºé—´çš„é«˜ä½
            // 2. å¤§å°æœ‰é™ï¼šé€šå¸¸8MB (å¯é€šè¿‡ulimit -sæŸ¥çœ‹)
            // 3. å‘ä¸‹å¢é•¿ï¼šä»é«˜åœ°å€å‘ä½åœ°å€å¢é•¿
            
            analyzeStackUsage()
        }
    }
    
    private fun analyzeStackUsage() {
        // é€’å½’è°ƒç”¨æµ‹è¯•æ ˆç©ºé—´ä½¿ç”¨
        fun recursiveFunction(depth: Int) {
            val localArray = ByteArray(1024)  // æ¯æ¬¡è°ƒç”¨å ç”¨1KBæ ˆç©ºé—´
            Log.d("Stack", "é€’å½’æ·±åº¦: $depth, æ ˆå¸§å¤§å°: ~1KB")
            
            if (depth < 1000) {
                recursiveFunction(depth + 1)
            }
        }
        
        try {
            recursiveFunction(0)
        } catch (e: StackOverflowError) {
            Log.e("Stack", "æ ˆæº¢å‡ºï¼ä¸»çº¿ç¨‹æ ˆç©ºé—´è€—å°½")
        }
    }
}
```

### æ™®é€šçº¿ç¨‹ï¼šç‹¬ç«‹åˆ†é…æ ˆç©ºé—´

```kotlin
class WorkerThreadStackAnalysis {
    
    fun analyzeWorkerThreadStack() {
        thread {
            Log.d("Stack", "è¿è¡Œåœ¨å·¥ä½œçº¿ç¨‹ï¼Œä½¿ç”¨ç‹¬ç«‹åˆ†é…çš„æ ˆç©ºé—´")
            
            // å·¥ä½œçº¿ç¨‹æ ˆçš„ç‰¹ç‚¹ï¼š
            // 1. åŠ¨æ€åˆ†é…ï¼šé€šè¿‡mmap()ç³»ç»Ÿè°ƒç”¨åˆ†é…
            // 2. å¯é…ç½®å¤§å°ï¼šé»˜è®¤1MBï¼Œå¯é€šè¿‡Threadæ„é€ å‡½æ•°é…ç½®
            // 3. ç‹¬ç«‹ç®¡ç†ï¼šæ¯ä¸ªçº¿ç¨‹éƒ½æœ‰è‡ªå·±çš„æ ˆç©ºé—´
            
            compareStackSpaces()
        }
    }
    
    private fun compareStackSpaces() {
        // åˆ›å»ºä¸åŒæ ˆå¤§å°çš„çº¿ç¨‹è¿›è¡Œå¯¹æ¯”
        val smallStackThread = Thread(null, {
            analyzeCurrentThreadStack("å°æ ˆçº¿ç¨‹")
        }, "SmallStack", 512 * 1024)  // 512KBæ ˆ
        
        val largeStackThread = Thread(null, {
            analyzeCurrentThreadStack("å¤§æ ˆçº¿ç¨‹")
        }, "LargeStack", 2 * 1024 * 1024)  // 2MBæ ˆ
        
        smallStackThread.start()
        largeStackThread.start()
        
        smallStackThread.join()
        largeStackThread.join()
    }
    
    private fun analyzeCurrentThreadStack(threadName: String) {
        val threadId = Thread.currentThread().id
        Log.d("Stack", "$threadName (ID: $threadId) å¼€å§‹æ ˆç©ºé—´åˆ†æ")
        
        // æ¨¡æ‹Ÿé€’å½’è°ƒç”¨æµ‹è¯•æ ˆç©ºé—´é™åˆ¶
        testStackLimit(threadName, 0)
    }
    
    private fun testStackLimit(threadName: String, depth: Int) {
        val localData = ByteArray(512)  // æ¯å±‚é€’å½’å ç”¨512å­—èŠ‚
        
        if (depth % 100 == 0) {
            Log.d("Stack", "$threadName é€’å½’æ·±åº¦: $depth")
        }
        
        try {
            if (depth < 5000) {  // é™åˆ¶é€’å½’æ·±åº¦é¿å…æ— é™é€’å½’
                testStackLimit(threadName, depth + 1)
            }
        } catch (e: StackOverflowError) {
            Log.e("Stack", "$threadName åœ¨æ·±åº¦ $depth å‘ç”Ÿæ ˆæº¢å‡º")
        }
    }
}
```

## å†…å­˜åˆ†é…çš„æ±‡ç¼–çº§å’Œå­—èŠ‚ç çº§å¯¹æ¯”

### Nativeæ ˆå¸§ï¼šæ±‡ç¼–çº§åˆ«çš„å†…å­˜å¸ƒå±€

```cpp
// C/C++å‡½æ•°è°ƒç”¨çš„æ±‡ç¼–çº§æ ˆå¸§ç»“æ„
void nativeFunction(int param1, float param2) {
    // æ±‡ç¼–ä»£ç ä¼šç”Ÿæˆç±»ä¼¼è¿™æ ·çš„æ ˆå¸§ï¼š
    /*
    é«˜åœ°å€
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚   è¿”å›åœ°å€       â”‚ â† è°ƒç”¨è€…çš„ä¸‹ä¸€æ¡æŒ‡ä»¤åœ°å€
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  
    â”‚   æ—§çš„EBP       â”‚ â† è°ƒç”¨è€…çš„æ ˆåŸºæŒ‡é’ˆ
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â† å½“å‰EBPæŒ‡å‘è¿™é‡Œ
    â”‚   å±€éƒ¨å˜é‡       â”‚
    â”‚   (char buffer[100]) â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚   å‚æ•°2 (param2) â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚   å‚æ•°1 (param1) â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â† å½“å‰ESPæŒ‡å‘è¿™é‡Œ
    ä½åœ°å€
    */
    
    char buffer[100];  // åœ¨æ ˆä¸Šåˆ†é…100å­—èŠ‚
    int* dynamicMem = (int*)malloc(sizeof(int) * 10);  // åœ¨å †ä¸Šåˆ†é…40å­—èŠ‚
    
    // æ ˆå†…å­˜ï¼šè‡ªåŠ¨ç®¡ç†ï¼Œå‡½æ•°è¿”å›æ—¶è‡ªåŠ¨é‡Šæ”¾
    // å †å†…å­˜ï¼šæ‰‹åŠ¨ç®¡ç†ï¼Œéœ€è¦æ˜¾å¼free()
    free(dynamicMem);
}
```

### Javaæ ˆå¸§ï¼šå­—èŠ‚ç çº§åˆ«çš„å†…å­˜ç»“æ„

```kotlin
class JavaStackFrameDemo {
    
    fun javaFunction(param1: Int, param2: Float): String {
        // JVMå­—èŠ‚ç ä¼šç”Ÿæˆè¿™æ ·çš„æ ˆå¸§ç»“æ„ï¼š
        /*
        Javaæ ˆå¸§ç»“æ„:
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚    æ“ä½œæ•°æ ˆ          â”‚ â† å­˜å‚¨ä¸­é—´è®¡ç®—ç»“æœ
        â”‚  (Operand Stack)    â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚    å±€éƒ¨å˜é‡è¡¨        â”‚ â† this, param1, param2, localVar
        â”‚ (Local Variables)   â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚    è¿è¡Œæ—¶å¸¸é‡æ± å¼•ç”¨   â”‚ â† æŒ‡å‘ç±»çš„å¸¸é‡æ± 
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚    æ–¹æ³•è¿”å›åœ°å€       â”‚ â† å­—èŠ‚ç è¿”å›ä½ç½®
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚    åŠ¨æ€é“¾æ¥ä¿¡æ¯       â”‚ â† æ–¹æ³•è°ƒç”¨çš„é“¾æ¥ä¿¡æ¯
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        */
        
        val localVar = "å±€éƒ¨å˜é‡"  // å­˜å‚¨åœ¨å±€éƒ¨å˜é‡è¡¨slot 3
        val result = param1 + param2  // ä¸­é—´è®¡ç®—åœ¨æ“ä½œæ•°æ ˆä¸­è¿›è¡Œ
        
        return "$localVar: $result"  // å­—ç¬¦ä¸²æ‹¼æ¥æ“ä½œåœ¨æ“ä½œæ•°æ ˆä¸­å®Œæˆ
    }
    
    fun demonstrateStackFrameDetails() {
        // å¯ä»¥é€šè¿‡å­—èŠ‚ç æŸ¥çœ‹è¯¦ç»†çš„æ ˆå¸§æ“ä½œ
        // javap -c JavaStackFrameDemo.class
        /*
        ç¼–è¯‘åçš„å­—èŠ‚ç ç¤ºä¾‹:
        public java.lang.String javaFunction(int, float);
          Code:
             0: ldc           #2    // String å±€éƒ¨å˜é‡
             2: astore_3            // å­˜å‚¨åˆ°å±€éƒ¨å˜é‡è¡¨slot 3
             3: iload_1             // åŠ è½½param1åˆ°æ“ä½œæ•°æ ˆ
             4: fload_2             // åŠ è½½param2åˆ°æ“ä½œæ•°æ ˆ  
             5: fadd                // æ“ä½œæ•°æ ˆä¸­æ‰§è¡ŒåŠ æ³•
             6: fstore        4     // å­˜å‚¨ç»“æœåˆ°å±€éƒ¨å˜é‡è¡¨slot 4
             8: new           #3    // StringBuilder
            11: dup
            12: invokespecial #4   // StringBuilder.<init>
            ... (å­—ç¬¦ä¸²æ‹¼æ¥çš„å­—èŠ‚ç )
            25: areturn            // è¿”å›å¼•ç”¨ç±»å‹ç»“æœ
        */
        
        val result = javaFunction(42, 3.14f)
        Log.d("StackFrame", "Javaæ–¹æ³•è°ƒç”¨ç»“æœ: $result")
    }
}
```

### å®é™…å¯¹æ¯”ï¼šNative vs Javaè°ƒç”¨å¼€é”€

```kotlin
class StackFramePerformanceComparison {
    
    // Nativeæ–¹æ³•å£°æ˜
    external fun nativeCalculation(a: Int, b: Float): Float
    
    // Javaæ–¹æ³•
    fun javaCalculation(a: Int, b: Float): Float {
        return a * b + 1.0f
    }
    
    fun compareCallOverhead() {
        val iterations = 1000000
        
        // æµ‹è¯•Javaæ–¹æ³•è°ƒç”¨å¼€é”€
        val javaStartTime = System.nanoTime()
        repeat(iterations) {
            javaCalculation(42, 3.14f)
        }
        val javaEndTime = System.nanoTime()
        val javaTime = (javaEndTime - javaStartTime) / 1000000  // è½¬æ¢ä¸ºæ¯«ç§’
        
        // æµ‹è¯•Nativeæ–¹æ³•è°ƒç”¨å¼€é”€
        val nativeStartTime = System.nanoTime()
        repeat(iterations) {
            nativeCalculation(42, 3.14f)
        }
        val nativeEndTime = System.nanoTime()
        val nativeTime = (nativeEndTime - nativeStartTime) / 1000000
        
        Log.d("Performance", """
            æ–¹æ³•è°ƒç”¨æ€§èƒ½å¯¹æ¯” ($iterations æ¬¡è°ƒç”¨):
            Javaæ–¹æ³•è€—æ—¶: ${javaTime}ms
            Nativeæ–¹æ³•è€—æ—¶: ${nativeTime}ms
            JNIè°ƒç”¨å¼€é”€: ${if (nativeTime > javaTime) "+${nativeTime - javaTime}ms" else "-${javaTime - nativeTime}ms"}
        """.trimIndent())
    }
}
```

## ActivityåŠ è½½å›¾ç‰‡çš„å®Œæ•´å†…å­˜äº¤äº’åˆ†æ

### CPUåˆ°GPUçš„å†…å­˜æ•°æ®æµ

```kotlin
class ImageMemoryFlowAnalysis : AppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        demonstrateCompleteImageFlow()
    }
    
    private fun demonstrateCompleteImageFlow() {
        val imageView = findViewById<ImageView>(R.id.imageView)
        
        Log.d("ImageFlow", "=== å¼€å§‹å›¾ç‰‡åŠ è½½å†…å­˜åˆ†æ ===")
        
        // ç¬¬1é˜¶æ®µï¼šCPUå†…å­˜ä¸­è§£ç å›¾ç‰‡
        val memBefore = Debug.MemoryInfo()
        Debug.getMemoryInfo(memBefore)
        
        Log.d("ImageFlow", "ç¬¬1é˜¶æ®µï¼šCPUè§£ç å›¾ç‰‡åˆ°å†…å­˜")
        val bitmap = BitmapFactory.decodeResource(resources, R.drawable.large_image)
        
        val memAfterDecode = Debug.MemoryInfo()
        Debug.getMemoryInfo(memAfterDecode)
        
        val cpuMemoryIncrease = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            memAfterDecode.nativeHeap - memBefore.nativeHeap  // Android 8+ åœ¨Nativeå †
        } else {
            memAfterDecode.dalvikHeap - memBefore.dalvikHeap   // Android 7- åœ¨Javaå †
        }
        
        Log.d("ImageFlow", "CPUå†…å­˜å¢é•¿: ${cpuMemoryIncrease}KB")
        Log.d("ImageFlow", "å›¾ç‰‡å°ºå¯¸: ${bitmap.width}x${bitmap.height}")
        Log.d("ImageFlow", "åƒç´ æ ¼å¼: ${bitmap.config}")
        Log.d("ImageFlow", "ç†è®ºå†…å­˜: ${bitmap.width * bitmap.height * 4 / 1024}KB")
        
        // ç¬¬2é˜¶æ®µï¼šCPUå†…å­˜åˆ°GPUæ˜¾å­˜çš„ä¼ è¾“
        Log.d("ImageFlow", "ç¬¬2é˜¶æ®µï¼šä¼ è¾“å›¾ç‰‡æ•°æ®åˆ°GPUæ˜¾å­˜")
        
        val memBeforeGPU = Debug.MemoryInfo()
        Debug.getMemoryInfo(memBeforeGPU)
        
        // è®¾ç½®åˆ°ImageViewä¼šè§¦å‘GPUçº¹ç†åˆ›å»º
        imageView.setImageBitmap(bitmap)
        imageView.post {
            // ç¡®ä¿æ¸²æŸ“å®Œæˆåå†æµ‹é‡GPUå†…å­˜
            val memAfterGPU = Debug.MemoryInfo()
            Debug.getMemoryInfo(memAfterGPU)
            
            val gpuMemoryIncrease = memAfterGPU.graphics - memBeforeGPU.graphics
            Log.d("ImageFlow", "GPUå†…å­˜å¢é•¿: ${gpuMemoryIncrease}KB")
            
            analyzeMemoryDistribution(memAfterGPU)
        }
    }
    
    private fun analyzeMemoryDistribution(memInfo: Debug.MemoryInfo) {
        Log.d("ImageFlow", """
            === å†…å­˜åˆ†å¸ƒåˆ†æ ===
            CPUä¾§å†…å­˜:
            - Javaå †: ${memInfo.dalvikHeap}KB (å¯¹è±¡å…ƒæ•°æ®)
            - Nativeå †: ${memInfo.nativeHeap}KB (åƒç´ æ•°æ® Android 8+)
            - ä»£ç æ®µ: ${memInfo.code}KB (åº”ç”¨ç¨‹åºä»£ç )
            - æ ˆç©ºé—´: ${memInfo.stack}KB (æ–¹æ³•è°ƒç”¨æ ˆ)
            
            GPUä¾§å†…å­˜:
            - æ˜¾å­˜: ${memInfo.graphics}KB (çº¹ç†ã€ç¼“å†²åŒº)
            
            æ€»å†…å­˜ä½¿ç”¨: ${memInfo.totalPss}KB
        """.trimIndent())
        
        // åˆ†æå†…å­˜ä½¿ç”¨æ¨¡å¼
        analyzeMemoryPattern(memInfo)
    }
    
    private fun analyzeMemoryPattern(memInfo: Debug.MemoryInfo) {
        val totalCPU = memInfo.dalvikHeap + memInfo.nativeHeap + memInfo.code + memInfo.stack
        val totalGPU = memInfo.graphics
        val cpuPercentage = (totalCPU.toFloat() / memInfo.totalPss * 100).toInt()
        val gpuPercentage = (totalGPU.toFloat() / memInfo.totalPss * 100).toInt()
        
        Log.d("ImageFlow", """
            === å†…å­˜ä½¿ç”¨æ¨¡å¼ ===
            CPUå†…å­˜å æ¯”: $cpuPercentage%
            GPUå†…å­˜å æ¯”: $gpuPercentage%
            å…¶ä»–ç³»ç»Ÿå†…å­˜: ${100 - cpuPercentage - gpuPercentage}%
            
            å†…å­˜ä¼˜åŒ–å»ºè®®:
            ${generateOptimizationAdvice(cpuPercentage, gpuPercentage)}
        """.trimIndent())
    }
    
    private fun generateOptimizationAdvice(cpuPercent: Int, gpuPercent: Int): String {
        return when {
            cpuPercent > 60 -> "CPUå†…å­˜å ç”¨è¿‡é«˜ï¼Œå»ºè®®ï¼š1.ä½¿ç”¨å›¾ç‰‡å‹ç¼© 2.å®ç°å¯¹è±¡æ±  3.åŠæ—¶é‡Šæ”¾å¤§å¯¹è±¡"
            gpuPercent > 40 -> "GPUå†…å­˜å ç”¨è¿‡é«˜ï¼Œå»ºè®®ï¼š1.é™ä½å›¾ç‰‡åˆ†è¾¨ç‡ 2.ä½¿ç”¨åˆé€‚çš„çº¹ç†æ ¼å¼ 3.å®ç°çº¹ç†å¤ç”¨"
            else -> "å†…å­˜ä½¿ç”¨å‡è¡¡ï¼Œå¯ç»§ç»­ç›‘æ§å’Œä¼˜åŒ–"
        }
    }
}
```

### GPUå†…å­˜ç®¡ç†çš„æ·±å…¥åˆ†æ

```kotlin
class GPUMemoryAnalysis {
    
    fun analyzeTextureMemoryUsage(bitmap: Bitmap) {
        // GPUçº¹ç†å†…å­˜è®¡ç®—
        val textureSize = calculateTextureMemorySize(bitmap)
        
        Log.d("GPU", """
            GPUçº¹ç†å†…å­˜åˆ†æ:
            åŸå§‹å›¾ç‰‡: ${bitmap.width}x${bitmap.height}
            åƒç´ æ ¼å¼: ${bitmap.config}
            CPUå†…å­˜: ${bitmap.byteCount / 1024}KB
            GPUçº¹ç†å†…å­˜: ${textureSize / 1024}KB
            å†…å­˜æ”¾å¤§å€æ•°: ${textureSize.toFloat() / bitmap.byteCount}
        """.trimIndent())
        
        explainTextureMemoryDifference(bitmap, textureSize)
    }
    
    private fun calculateTextureMemorySize(bitmap: Bitmap): Int {
        // GPUçº¹ç†å¯èƒ½éœ€è¦é¢å¤–å†…å­˜ï¼š
        // 1. çº¹ç†éœ€è¦2çš„å¹‚æ¬¡æ–¹å°ºå¯¸ï¼ˆæŸäº›GPUï¼‰
        // 2. å¯èƒ½éœ€è¦Mipmapå±‚æ¬¡
        // 3. å¯èƒ½æœ‰å†…å­˜å¯¹é½è¦æ±‚
        
        val width = bitmap.width
        val height = bitmap.height
        
        // è®¡ç®—æœ€æ¥è¿‘çš„2çš„å¹‚æ¬¡æ–¹å°ºå¯¸
        val textureWidth = nextPowerOfTwo(width)
        val textureHeight = nextPowerOfTwo(height)
        
        // åŸºç¡€çº¹ç†å†…å­˜
        val baseTextureSize = textureWidth * textureHeight * 4  // RGBA
        
        // Mipmapé¢å¤–å†…å­˜ï¼ˆå¦‚æœå¯ç”¨ï¼‰
        val mipmapSize = baseTextureSize / 3  // å¤§çº¦é¢å¤–33%
        
        return baseTextureSize + mipmapSize
    }
    
    private fun nextPowerOfTwo(value: Int): Int {
        var result = 1
        while (result < value) {
            result *= 2
        }
        return result
    }
    
    private fun explainTextureMemoryDifference(bitmap: Bitmap, textureSize: Int) {
        val cpuSize = bitmap.byteCount
        val ratio = textureSize.toFloat() / cpuSize
        
        Log.d("GPU", """
            CPU vs GPUå†…å­˜å·®å¼‚åŸå› :
            1. å°ºå¯¸å¯¹é½: ${bitmap.width}x${bitmap.height} â†’ ${nextPowerOfTwo(bitmap.width)}x${nextPowerOfTwo(bitmap.height)}
            2. Mipmapç”Ÿæˆ: éœ€è¦é¢å¤–33%å†…å­˜ç”¨äºä¸åŒåˆ†è¾¨ç‡å±‚æ¬¡
            3. å†…å­˜å¯¹é½: GPUè®¿é—®æ•ˆç‡è¦æ±‚ç‰¹å®šçš„å†…å­˜å¯¹é½
            4. æ ¼å¼è½¬æ¢: å¯èƒ½éœ€è¦æ ¼å¼è½¬æ¢äº§ç”Ÿçš„ä¸´æ—¶å†…å­˜
            
            å®é™…å†…å­˜æ”¾å¤§: ${String.format("%.2f", ratio)}å€
        """.trimIndent())
    }
}
```

é€šè¿‡è¿™ä¸ªåˆ†æï¼Œæˆ‘ä»¬å¯ä»¥æ¸…æ¥šåœ°çœ‹åˆ°Androidç³»ç»Ÿæ˜¯å¦‚ä½•å·§å¦™åœ°åœ¨åŒä¸€ä¸ªè¿›ç¨‹ç©ºé—´å†…ï¼Œé€šè¿‡åˆ†å±‚çš„å †ç®¡ç†ç­–ç•¥ï¼Œå®ç°äº†çµæ´»é«˜æ•ˆçš„å†…å­˜åˆ†é…å’Œç®¡ç†æœºåˆ¶ã€‚