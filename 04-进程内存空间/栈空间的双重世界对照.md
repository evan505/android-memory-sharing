# 栈空间的双重世界：Java栈 vs 进程栈深度对照

## 概述
在Android应用中，同时存在着两个"栈"的概念：Java虚拟机栈和进程地址空间中的栈。它们服务于不同的层次，但又密切相关。理解这两个栈的关系是掌握Android内存管理的关键。

## 栈的双重含义

### 1. 进程空间中的栈段 (Process Stack Segment)

这是操作系统级别的栈，每个线程都有独立的栈空间：

```
进程虚拟地址空间 (以主线程为例)
0xFFFFFFFF  ┌─────────────────────┐
            │    Kernel Space     │
0xC0000000  ├─────────────────────┤
            │                     │
            │   Thread Stack      │ ← 进程栈段
            │                     │   (Native函数调用)
            │ ┌─────────────────┐ │
            │ │  Stack Frame N  │ │ ↑ 栈顶 (低地址)
            │ ├─────────────────┤ │ │
            │ │  Stack Frame..  │ │ │ 向下增长
            │ ├─────────────────┤ │ │
            │ │  Stack Frame 1  │ │ ↓ 栈底 (高地址)
            │ └─────────────────┘ │
0xBF000000  ├─────────────────────┤ ← 栈段起始地址
            │  Memory Mapping     │
            │       Region        │
0x40000000  └─────────────────────┘
```

### 2. ART虚拟机栈 (ART Java Stack)

这是每个Java线程的虚拟机栈，存储在ART虚拟机内部：

```
ART虚拟机内部结构
┌─────────────────────────────────────┐
│            ART Runtime              │
├─────────────────────────────────────┤
│          Java Thread Pool          │
│  ┌─────────────────────────────────┐│
│  │        Main Thread              ││
│  │  ┌───────────────────────────┐  ││
│  │  │      Java Stack           │  ││ 
│  │  │ ┌───────────────────────┐ │  ││
│  │  │ │   Method Frame N      │ │  ││ ↑ 栈顶
│  │  │ ├───────────────────────┤ │  ││ │
│  │  │ │   Method Frame ...    │ │  ││ │ 增长方向
│  │  │ ├───────────────────────┤ │  ││ │
│  │  │ │   Method Frame 1      │ │  ││ ↓ 栈底
│  │  │ └───────────────────────┘ │  ││
│  │  └───────────────────────────┘  ││
│  └─────────────────────────────────┘│
└─────────────────────────────────────┘
```

## 详细对照分析

### 栈的基本属性对比

| 属性 | 进程栈 (Native Stack) | Java栈 (ART Stack) |
|------|----------------------|-------------------|
| **管理者** | Linux内核 + glibc | ART虚拟机 |
| **存储位置** | 进程虚拟地址空间的栈段 | ART堆内分配的内存区域 |
| **大小限制** | ulimit -s (通常8MB) | -Xss参数 (通常1MB) |
| **增长方向** | 向下增长 (高地址→低地址) | 向上增长 (低地址→高地址) |
| **线程独立性** | 每个线程独立的栈段 | 每个Java线程独立的栈结构 |
| **溢出检测** | 硬件MMU检测 | ART虚拟机软件检测 |

### 栈帧结构对比

#### 进程栈帧 (Native Stack Frame)
```c++
// C++函数调用的栈帧结构
void nativeFunction(int param1, char* param2) {
    int localVar1;
    double localVar2;
    callAnotherFunction();
}
```

**进程栈帧布局**：
```
高地址 ┌─────────────────────────┐
      │    参数2 (char*)         │ ← 函数参数
      ├─────────────────────────┤
      │    参数1 (int)           │
      ├─────────────────────────┤
      │    返回地址              │ ← 调用者的下一条指令
      ├─────────────────────────┤
      │    保存的寄存器          │ ← rbp, rbx等
      ├─────────────────────────┤
      │    localVar1 (int)       │ ← 局部变量
      ├─────────────────────────┤
      │    localVar2 (double)    │
      ├─────────────────────────┤
      │    临时变量区            │
低地址 └─────────────────────────┘ ← 当前栈指针 (rsp)
```

#### Java栈帧 (Java Stack Frame)
```java
// Java方法调用的栈帧结构
public void javaMethod(int param1, String param2) {
    int localVar1 = 10;
    Object localVar2 = new Object();
    anotherMethod();
}
```

**Java栈帧布局**：
```
低地址 ┌─────────────────────────┐ ← 栈底方向
      │    局部变量表            │
      │ ┌─────────────────────┐ │
      │ │ param1 (int)        │ │ ← 方法参数
      │ │ param2 (String ref) │ │
      │ │ localVar1 (int)     │ │ ← 局部变量
      │ │ localVar2 (Object)  │ │
      │ └─────────────────────┘ │
      ├─────────────────────────┤
      │    操作数栈              │
      │ ┌─────────────────────┐ │
      │ │    临时计算数据      │ │ ← 表达式计算
      │ │    方法调用参数      │ │
      │ └─────────────────────┘ │
      ├─────────────────────────┤
      │    动态链接信息          │ ← 方法区的引用
      ├─────────────────────────┤
      │    方法返回地址          │ ← 调用者的字节码位置
      ├─────────────────────────┤
      │    附加信息              │ ← 异常处理等
高地址 └─────────────────────────┘ ← 栈顶方向
```

## 两个栈的交互关系

### 1. ART虚拟机启动时的栈创建

当Android应用启动时，会创建两层栈结构：

```cpp
// 应用启动时的栈创建过程
void Thread::CreateNativeThread() {
    // 1. 系统为线程分配Native栈空间
    void* native_stack = mmap(NULL, STACK_SIZE, 
                              PROT_READ | PROT_WRITE,
                              MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    
    // 2. 在Native栈上执行线程入口函数
    pthread_create(&thread_id, &attr, ThreadEntry, this);
}

void Thread::ThreadEntry(void* arg) {
    Thread* self = reinterpret_cast<Thread*>(arg);
    
    // 3. ART虚拟机为这个线程创建Java栈
    self->CreateJavaStack();
    
    // 4. 开始执行Java代码
    self->RunJavaMain();
}

void Thread::CreateJavaStack() {
    // 在ART堆中分配Java栈内存
    java_stack_ = heap_->Allocate(JAVA_STACK_SIZE);
    
    // 初始化Java栈结构
    InitializeJavaStackFrame(java_stack_);
}
```

### 2. JNI调用时的栈切换

Java方法调用Native方法时，会发生栈的切换：

```java
// Java代码
public class MainActivity extends Activity {
    static {
        System.loadLibrary("native-lib");
    }
    
    // Java栈中执行
    public void onCreate(Bundle savedInstanceState) {
        int result = nativeCalculate(10, 20);  // ← 栈切换点
    }
    
    // 声明native方法
    public native int nativeCalculate(int a, int b);
}
```

```cpp
// C++代码 (JNI实现)
extern "C" JNIEXPORT jint JNICALL
Java_com_example_MainActivity_nativeCalculate(
    JNIEnv *env, jobject thiz, jint a, jint b) {
    
    // 现在在Native栈中执行
    int result = complexCalculation(a, b);
    return result;  // ← 返回时栈再次切换
}
```

**栈切换过程**：
```
1. Java方法在Java栈帧中执行
   ↓ (JNI调用)
2. ART虚拟机保存Java栈状态
   ↓
3. 切换到Native栈继续执行
   ↓ (JNI返回)  
4. 恢复Java栈状态
   ↓
5. 继续在Java栈帧中执行
```

### 3. 异常处理中的栈展开

当发生异常时，两个栈都参与处理：

```java
// Java异常处理
try {
    nativeFunction();  // 可能抛出异常的Native调用
} catch (Exception e) {
    e.printStackTrace();  // 打印混合栈轨迹
}
```

**混合栈轨迹示例**：
```
java.lang.RuntimeException: Native exception
    at com.example.MainActivity.nativeFunction(Native Method)     ← Native栈
    at com.example.MainActivity.callNative(MainActivity.java:45)  ← Java栈  
    at com.example.MainActivity.onCreate(MainActivity.java:32)    ← Java栈
    at android.app.Activity.performCreate(Activity.java:7136)    ← Java栈
    ... (更多Java栈帧)
```

## 内存分配的层次关系

### 栈内存的分配层次

```
Linux内核内存管理
    ↓ (mmap系统调用)
进程虚拟地址空间的栈段
    ↓ (pthread_create)
Native线程栈
    ↓ (ART虚拟机分配)
Java线程栈 (在ART堆中分配)
    ↓ (方法调用)
Java栈帧
```

### 具体的内存布局关系

```
进程虚拟地址空间视角：
┌─────────────────────────────────────┐
│        Native Thread Stack         │
│  ┌───────────────────────────────┐  │
│  │    Native Stack Frames        │  │ ← C++/JNI函数调用
│  ├───────────────────────────────┤  │
│  │    ART Virtual Machine        │  │
│  │    Runtime Code               │  │ ← ART虚拟机本身的执行
│  └───────────────────────────────┘  │
└─────────────────────────────────────┘

ART虚拟机内部视角：
┌─────────────────────────────────────┐
│          ART Heap Space             │
│  ┌───────────────────────────────┐  │
│  │      Java Thread Stacks       │  │ ← 分配给Java栈的内存
│  │ ┌─────────────────────────┐   │  │
│  │ │   Main Thread Stack     │   │  │
│  │ │ ┌─────────────────────┐ │   │  │
│  │ │ │   Java Stack Frames │ │   │  │ ← Java方法调用
│  │ │ └─────────────────────┘ │   │  │
│  │ └─────────────────────────┘   │  │
│  └───────────────────────────────┘  │
└─────────────────────────────────────┘
```

## 栈溢出的不同表现

### Native栈溢出 (StackOverflowError at Native level)
```cpp
// 深度递归导致Native栈溢出
void deepRecursion(int depth) {
    char buffer[1024];  // 消耗栈空间
    if (depth > 0) {
        deepRecursion(depth - 1);  // 递归调用
    }
}
// 结果：Segmentation fault (SIGSEGV)
```

### Java栈溢出 (StackOverflowError)
```java
// 深度递归导致Java栈溢出
public void deepRecursion(int depth) {
    int[] buffer = new int[100];  // 局部变量
    if (depth > 0) {
        deepRecursion(depth - 1);  // 递归调用
    }
}
// 结果：java.lang.StackOverflowError
```

### 栈溢出检测机制

| 栈类型 | 检测机制 | 错误类型 | 处理方式 |
|--------|----------|----------|----------|
| **Native栈** | MMU硬件检测 | SIGSEGV信号 | 进程终止或信号处理 |
| **Java栈** | ART软件检测 | StackOverflowError | Java异常处理机制 |

## 调试和监控

### 1. 查看Native栈信息
```bash
# 查看线程栈大小限制
ulimit -s

# 查看进程的线程栈信息
adb shell cat /proc/$(pidof com.example.app)/maps | grep stack
```

### 2. 查看Java栈信息
```kotlin
// 获取当前线程的栈轨迹
val stackTrace = Thread.currentThread().stackTrace
for (element in stackTrace) {
    Log.d("Stack", "${element.className}.${element.methodName}:${element.lineNumber}")
}
```

### 3. 混合栈轨迹分析
```bash
# 使用ndk-stack分析Native崩溃
adb logcat | ndk-stack -sym /path/to/symbols
```

## 实际应用中的考量

### 栈大小优化
```kotlin
// 创建线程时指定栈大小
val thread = Thread(null, {
    // 线程任务
}, "WorkerThread", 2 * 1024 * 1024)  // 2MB栈大小

thread.start()
```

### JNI调用优化
```cpp
// 减少JNI调用中的栈使用
JNIEXPORT void JNICALL 
Java_com_example_Native_processData(JNIEnv *env, jobject obj, jintArray data) {
    // 避免在栈上分配大数组
    jint* elements = env->GetIntArrayElements(data, nullptr);
    
    // 处理数据...
    
    env->ReleaseIntArrayElements(data, elements, 0);
}
```

## 栈帧结构的深度剖析

### Native栈帧的汇编层面细节

让我们通过一个实际的C++函数调用来看Native栈帧的详细结构：

```cpp
int calculateSum(int a, int b, int c) {
    int result = a + b + c;
    int temp = result * 2;
    return temp;
}

void caller() {
    int x = calculateSum(10, 20, 30);
}
```

**x86-64架构下的实际栈帧布局**：
```
调用 calculateSum(10, 20, 30) 时的栈帧：

高地址  ┌─────────────────────────────┐
       │  caller()的局部变量 int x    │ ← caller函数的栈帧
       ├─────────────────────────────┤
       │  参数3: c = 30 (通过栈传递) │ ← 参数区域  
       │  参数2: b = 20 (寄存器rsi)  │   
       │  参数1: a = 10 (寄存器rdi)  │   
       ├─────────────────────────────┤
       │  返回地址 (caller中的下一行) │ ← 8字节，关键！
       ├─────────────────────────────┤
       │  保存的rbp (栈基址指针)      │ ← 8字节，链接上一栈帧
       ├─────────────────────────────┤  ← rbp指向这里
       │  局部变量: result (int)      │ ← 4字节
       ├─────────────────────────────┤
       │  局部变量: temp (int)        │ ← 4字节  
       ├─────────────────────────────┤
       │  栈对齐填充                  │ ← 保证16字节对齐
低地址  └─────────────────────────────┘ ← rsp指向这里
```

**对应的汇编代码**：
```assembly
calculateSum:
    ; 函数序言 (prologue)
    pushq   %rbp              ; 保存调用者的栈基址
    movq    %rsp, %rbp        ; 设置新的栈基址
    subq    $16, %rsp         ; 为局部变量分配栈空间
    
    ; 保存参数到栈上
    movl    %edi, -4(%rbp)    ; a -> [rbp-4]
    movl    %esi, -8(%rbp)    ; b -> [rbp-8] 
    movl    %edx, -12(%rbp)   ; c -> [rbp-12]
    
    ; 计算 result = a + b + c
    movl    -4(%rbp), %eax    ; 加载 a
    addl    -8(%rbp), %eax    ; 加上 b
    addl    -12(%rbp), %eax   ; 加上 c
    movl    %eax, -16(%rbp)   ; 保存 result
    
    ; 计算 temp = result * 2
    movl    -16(%rbp), %eax   ; 加载 result
    addl    %eax, %eax        ; result * 2
    movl    %eax, -20(%rbp)   ; 保存 temp
    
    ; 返回值
    movl    -20(%rbp), %eax   ; 返回值放入eax
    
    ; 函数结尾 (epilogue)
    movq    %rbp, %rsp        ; 恢复栈指针
    popq    %rbp              ; 恢复调用者的栈基址
    retq                      ; 返回 (弹出返回地址并跳转)
```

### Java栈帧的字节码层面细节

对应的Java代码和栈帧结构：

```java
public int calculateSum(int a, int b, int c) {
    int result = a + b + c;
    int temp = result * 2;  
    return temp;
}

public void caller() {
    int x = calculateSum(10, 20, 30);
}
```

**Java栈帧的详细结构**：
```
calculateSum(10, 20, 30) 的Java栈帧：

低地址  ┌─────────────────────────────┐ ← 栈帧底部
       │     局部变量表              │
       │ ┌─────────────────────────┐ │
       │ │ 0: this (对象引用)       │ │ ← 实例方法的隐式参数
       │ │ 1: a = 10 (int)         │ │
       │ │ 2: b = 20 (int)         │ │  
       │ │ 3: c = 30 (int)         │ │
       │ │ 4: result (int)         │ │ ← 局部变量
       │ │ 5: temp (int)           │ │
       │ └─────────────────────────┘ │
       ├─────────────────────────────┤
       │     操作数栈                │
       │ ┌─────────────────────────┐ │ ← 栈顶  
       │ │   当前计算的中间结果     │ │   (动态变化)
       │ └─────────────────────────┘ │ ← 栈底
       ├─────────────────────────────┤
       │   动态链接                  │ ← 指向方法区中的方法信息
       ├─────────────────────────────┤
       │   方法返回地址              │ ← caller方法中的字节码位置
       ├─────────────────────────────┤
       │   附加信息                  │ ← 异常表引用等
高地址  └─────────────────────────────┘ ← 栈帧顶部
```

**对应的字节码**：
```bytecode
public int calculateSum(int a, int b, int c);
  Code:
   Stack=2, Locals=6, Args_size=4
   0:   iload_1        ; 加载参数a到操作数栈
   1:   iload_2        ; 加载参数b到操作数栈  
   2:   iadd           ; 栈顶两个int相加
   3:   iload_3        ; 加载参数c到操作数栈
   4:   iadd           ; 再次相加
   5:   istore 4       ; 存储结果到局部变量4(result)
   7:   iload  4       ; 加载result到操作数栈
   9:   iconst_2       ; 加载常量2到操作数栈
   10:  imul           ; 乘法运算
   11:  istore 5       ; 存储到局部变量5(temp)
   13:  iload  5       ; 加载temp作为返回值
   15:  ireturn        ; 返回int值
```

### 栈帧创建和销毁的时序对比

#### Native栈帧的生命周期
```cpp
1. 函数调用前：
   - caller准备参数到寄存器/栈
   - call指令：推送返回地址到栈，跳转到目标函数

2. 函数入口：
   - push rbp：保存调用者的栈帧基址
   - mov rbp, rsp：建立新栈帧的基址
   - sub rsp, N：分配局部变量空间

3. 函数执行：
   - 使用rbp相对寻址访问参数和局部变量
   - 栈指针rsp可能因临时需要而调整

4. 函数返回：
   - mov rsp, rbp：恢复栈指针
   - pop rbp：恢复调用者的栈帧基址  
   - ret：弹出返回地址并跳转回调用者
```

#### Java栈帧的生命周期
```java
1. 方法调用前：
   - 调用者将参数压入操作数栈
   - invoke指令：创建新栈帧并传递参数

2. 方法入口：
   - ART创建新的栈帧结构
   - 初始化局部变量表（参数复制到局部变量）
   - 清空操作数栈

3. 方法执行：
   - 字节码指令操作局部变量表和操作数栈
   - 栈帧大小在编译期确定，运行时不变

4. 方法返回：
   - return指令：将返回值压入调用者的操作数栈
   - ART销毁当前栈帧，恢复调用者栈帧
```

### 栈帧中的内存访问模式

#### Native栈的内存访问
```cpp
// 直接内存地址访问
int function(int param) {
    int local = param + 10;      // [rbp-4] = [rbp+8] + 10
    return local * 2;            // eax = [rbp-4] * 2
}

// 汇编层面：
// movl 8(%rbp), %eax     ; 读取参数 param  
// addl $10, %eax         ; 加10
// movl %eax, -4(%rbp)    ; 写入局部变量 local
// movl -4(%rbp), %eax    ; 读取 local
// addl %eax, %eax        ; 乘以2
```

#### Java栈的内存访问  
```java
// 基于索引的访问
public int function(int param) {
    int local = param + 10;      // 局部变量表[1] = 局部变量表[0] + 10
    return local * 2;            // return 局部变量表[1] * 2  
}

// 字节码层面：
// iload_0        ; 将局部变量表[0]的值压入操作数栈
// bipush 10      ; 将常量10压入操作数栈  
// iadd           ; 弹出栈顶两个值相加，结果压回栈
// istore_1       ; 弹出栈顶值存储到局部变量表[1]
// iload_1        ; 加载局部变量表[1]到操作数栈
// iconst_2       ; 压入常量2
// imul           ; 乘法运算
// ireturn        ; 返回栈顶的int值
```

### 异常处理中的栈帧展开

#### Native异常的栈展开
```cpp
// C++异常处理的栈展开
void function3() {
    throw std::runtime_error("error");  // 异常抛出点
}

void function2() {
    function3();  // 栈帧将被展开
}

void function1() {
    try {
        function2();  // 栈帧将被展开  
    } catch (const std::exception& e) {
        // 捕获点，栈已展开到这里
    }
}
```

**Native栈展开过程**：
```
异常抛出时的栈状态：
┌─────────────────┐ ← function3()栈帧
├─────────────────┤ ← function2()栈帧  
├─────────────────┤ ← function1()栈帧
└─────────────────┘

异常处理系统展开栈：
1. 查找function3的异常处理表 → 无处理器
2. 展开function3栈帧，调用析构函数
3. 查找function2的异常处理表 → 无处理器  
4. 展开function2栈帧，调用析构函数
5. 查找function1的异常处理表 → 找到catch块
6. 跳转到catch块，保留function1栈帧
```

#### Java异常的栈帧展开
```java
// Java异常处理的栈帧展开  
public void method3() {
    throw new RuntimeException("error");  // 异常抛出点
}

public void method2() {
    method3();  // 栈帧将被展开
}

public void method1() {
    try {
        method2();  // 栈帧将被展开
    } catch (RuntimeException e) {
        // 捕获点，栈已展开到这里
    }
}
```

**Java栈展开过程**：
```
异常抛出时的栈状态：
┌─────────────────┐ ← method3()栈帧
├─────────────────┤ ← method2()栈帧
├─────────────────┤ ← method1()栈帧  
└─────────────────┘

ART虚拟机展开栈：
1. 查找method3的异常表 → 无匹配的异常处理器
2. 弹出method3栈帧，保存异常对象
3. 查找method2的异常表 → 无匹配的异常处理器
4. 弹出method2栈帧  
5. 查找method1的异常表 → 找到匹配的catch块
6. 跳转到catch块，保留method1栈帧
```

通过这个深入的栈帧结构剖析，我们可以看到Native栈和Java栈在最底层实现上的根本差异：Native栈直接操作内存地址和CPU寄存器，而Java栈通过抽象的局部变量表和操作数栈来模拟栈操作，提供了更高级的抽象和安全保障。

## Android线程栈的特殊机制：主线程 vs 普通线程

### 主线程使用进程原始栈

Android应用中存在一个很重要但容易被忽视的差异：

#### 主线程的栈来源
```cpp
// 进程启动时，Linux内核分配的原始栈空间
// 主线程直接继承并使用这个栈，无需额外分配
进程创建 → 内核分配栈段 → 主线程继承使用

进程虚拟地址空间:
0xC0000000  ├─────────────────────────────┤
            │                             │
            │   Main Thread Stack         │ ← 进程原始栈段
            │ (Process Original Stack)    │   (8MB，内核分配)
            │                             │
0xBF800000  ├─────────────────────────────┤
```

#### 普通线程的独立栈分配
```cpp
// 普通线程需要通过pthread_create单独分配栈空间
pthread_create → mmap()分配新栈 → 独立栈空间

内存映射区域:
┌─────────────────────────────────┐
│     Thread 1 Stack (2MB)       │ ← mmap()分配
├─────────────────────────────────┤
│     Thread 2 Stack (2MB)       │ ← mmap()分配  
├─────────────────────────────────┤
│     Thread 3 Stack (2MB)       │ ← mmap()分配
└─────────────────────────────────┘
```

### 线程创建的系统调用差异

#### 主线程启动过程
```cpp
// 无额外栈分配系统调用
Zygote.fork() 
  ↓
Linux内核创建进程 (包含默认栈段)
  ↓  
execv("/system/bin/app_process")
  ↓
主线程开始执行 (直接使用进程栈)
```

#### 普通线程创建过程  
```cpp
// 需要额外的内存分配系统调用
pthread_create()
  ↓
mmap(NULL, stack_size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS)
  ↓
clone(CLONE_VM|CLONE_FILES|CLONE_THREAD, new_stack_ptr)
  ↓
新线程在独立栈空间中开始执行
```

### 实际验证代码

```java
// Java层验证线程栈差异
public class ThreadStackDemo {
    static {
        System.loadLibrary("stackdemo");
    }
    
    public static void main(String[] args) {
        System.out.println("=== Main Thread Stack Info ===");
        analyzeCurrentThreadStack(); // 主线程栈信息
        
        Thread workerThread = new Thread(() -> {
            System.out.println("=== Worker Thread Stack Info ===");
            analyzeCurrentThreadStack(); // 普通线程栈信息
        }, "WorkerThread");
        
        workerThread.start();
        try {
            workerThread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    
    private static native void analyzeCurrentThreadStack();
}
```

```cpp
// Native实现 - 分析线程栈信息
extern "C" JNIEXPORT void JNICALL
Java_ThreadStackDemo_analyzeCurrentThreadStack(JNIEnv *env, jclass clazz) {
    // 获取线程信息
    pid_t tid = gettid();
    pthread_t pthread_id = pthread_self();
    
    // 获取栈信息
    void* stack_addr;
    size_t stack_size;
    pthread_attr_t attr;
    pthread_getattr_np(pthread_id, &attr);
    pthread_attr_getstack(&attr, &stack_addr, &stack_size);
    
    // 获取当前栈指针
    void* current_sp;
    #ifdef __x86_64__
        asm("movq %%rsp, %0" : "=r"(current_sp));
    #elif __aarch64__
        asm("mov %0, sp" : "=r"(current_sp));
    #endif
    
    __android_log_print(ANDROID_LOG_INFO, "StackAnalysis",
                       "Thread ID: %d", tid);
    __android_log_print(ANDROID_LOG_INFO, "StackAnalysis", 
                       "Pthread ID: %lu", (unsigned long)pthread_id);
    __android_log_print(ANDROID_LOG_INFO, "StackAnalysis",
                       "Stack Base: %p", stack_addr);
    __android_log_print(ANDROID_LOG_INFO, "StackAnalysis",
                       "Stack Size: %zu bytes (%.1f MB)", 
                       stack_size, stack_size / 1024.0 / 1024.0);
    __android_log_print(ANDROID_LOG_INFO, "StackAnalysis",
                       "Current SP: %p", current_sp);
    
    // 检查栈地址范围以判断栈类型
    bool is_main_thread_stack = ((uintptr_t)stack_addr >= 0xBF000000 && 
                                (uintptr_t)stack_addr <= 0xC0000000);
    
    __android_log_print(ANDROID_LOG_INFO, "StackAnalysis",
                       "Stack Type: %s", 
                       is_main_thread_stack ? "Process Original Stack (Main Thread)" 
                                            : "pthread Allocated Stack (Worker Thread)");
}
```

**预期输出对比**:
```
=== Main Thread Stack Info ===
Thread ID: 12345
Stack Base: 0xbf800000     ← 进程栈段地址  
Stack Size: 8388608 bytes (8.0 MB)  ← 系统默认大小
Stack Type: Process Original Stack (Main Thread)

=== Worker Thread Stack Info ===  
Thread ID: 12346
Stack Base: 0x7f12345000     ← 内存映射区域地址
Stack Size: 1048576 bytes (1.0 MB)  ← pthread默认大小
Stack Type: pthread Allocated Stack (Worker Thread)
```

### 性能和内存影响

#### 创建成本对比

| 操作 | 主线程 | 普通线程 |
|------|--------|----------|
| **栈分配** | 0 (进程创建时已分配) | ~50-100μs (mmap调用) |
| **内存开销** | 0 (复用进程栈) | 额外1-8MB每线程 |
| **地址空间** | 固定栈段 | 消耗虚拟地址空间 |
| **TLB效率** | 高 (集中的栈区域) | 较低 (分散的栈区域) |

#### 栈溢出行为差异

```java
// 主线程栈溢出 - 影响整个进程
public void mainThreadStackOverflow() {
    mainThreadStackOverflow(); // 无限递归
    // 结果: SIGSEGV → 整个应用崩溃
}

// 普通线程栈溢出 - 只影响当前线程  
new Thread(() -> {
    workerThreadStackOverflow(); // 无限递归
    // 结果: 该线程崩溃，主线程继续运行
}).start();
```

### 调试和监控差异

```bash
# 通过procfs查看线程栈映射
adb shell cat /proc/$(pidof com.example.app)/task/*/maps | grep stack

# 主线程栈 (通常显示为[stack])
bf800000-c0000000 rw-p 00000000 00:00 0    [stack]

# 普通线程栈 (显示为匿名映射)
7f1234000000-7f1234200000 rw-p 00000000 00:00 0
7f1256000000-7f1256200000 rw-p 00000000 00:00 0
```

这个差异说明了Android系统设计的巧妙之处：主线程作为进程的"原生执行流"，直接使用系统分配的栈空间，而其他线程则通过标准的pthread机制创建独立的栈空间。理解这个差异对于内存优化、性能调试和系统架构理解都很重要。