# 渐进式Android内存学习代码示例

## 概述

这个文件提供了一套完整的、渐进式的代码示例，帮助Java开发者从基础概念逐步深入到Android内存管理的各个层面。每个示例都包含详细的注释和验证方法。

---

## 第1级：基础概念验证（Java开发者起点）

### 1.1 堆内存 vs 栈内存的直观对比

```kotlin
/**
 * 目标：让Java开发者直观理解堆栈差异
 * 验证方法：使用Memory Profiler观察内存变化
 */
class Level1_HeapVsStack : AppCompatActivity() {
    
    // 全局变量：存储在数据段（不是堆也不是栈）
    companion object {
        private const val GLOBAL_CONSTANT = "我在数据段"
        private var globalCounter = 0
    }
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        Log.d("Level1", "=== 开始基础内存概念验证 ===")
        
        // 验证1：栈内存的特点
        demonstrateStackMemory()
        
        // 验证2：堆内存的特点  
        demonstrateHeapMemory()
        
        // 验证3：对比两者的生命周期
        compareLifecycles()
    }
    
    private fun demonstrateStackMemory() {
        Log.d("Stack", "--- 栈内存演示 ---")
        
        // 📚 栈内存特点：
        // 1. 局部变量存在栈中
        // 2. 方法调用结束，栈中数据自动清理
        // 3. 速度快，大小有限
        
        val stackVariable1 = 42  // int类型，存在栈中
        val stackVariable2 = "Hello"  // 引用存在栈中，"Hello"对象在堆中
        
        Log.d("Stack", "局部变量创建: $stackVariable1, $stackVariable2")
        
        // 递归调用演示栈的增长
        recursiveStackDemo(5)
        
        // 💡 验证方法：
        // 在Memory Profiler中观察Stack内存的变化
        // 注意：局部变量本身很小，主要观察方法调用的栈帧
        
    } // ← 方法结束，stackVariable1和stackVariable2的栈空间自动释放
    
    private fun recursiveStackDemo(depth: Int) {
        val localArray = IntArray(100) { it }  // 每层递归分配400字节栈空间
        
        Log.d("Stack", "递归深度: $depth, 数组大小: ${localArray.size}")
        
        if (depth > 1) {
            recursiveStackDemo(depth - 1)  // 继续递归，栈继续增长
        }
        
        // 💡 观察要点：
        // 1. 每次递归都会在栈中创建新的localArray
        // 2. 递归返回时，栈空间会自动回收
        // 3. 在Memory Profiler中Stack内存会随递归深度变化
    }
    
    private fun demonstrateHeapMemory() {
        Log.d("Heap", "--- 堆内存演示 ---")
        
        // 📚 堆内存特点：
        // 1. 对象存在堆中
        // 2. 需要GC回收
        // 3. 可以在方法间传递
        // 4. 大小灵活，但分配较慢
        
        val objectList = mutableListOf<User>()  // List对象在堆中
        
        // 在Memory Profiler中观察Java/Kotlin内存增长
        repeat(1000) { index ->
            val user = User("User$index")  // 每个User对象都在堆中分配
            objectList.add(user)
            
            if (index % 200 == 0) {
                val runtime = Runtime.getRuntime()
                val usedMemory = (runtime.totalMemory() - runtime.freeMemory()) / 1024
                Log.d("Heap", "创建${index}个对象，堆内存使用: ${usedMemory}KB")
            }
        }
        
        // 💡 验证方法：
        // 1. 在Memory Profiler中观察Java/Kotlin柱状图增长
        // 2. 可能看到GC事件（锯齿状下降）
        // 3. 对比创建对象前后的内存使用量
    }
    
    private fun compareLifecycles() {
        Log.d("Lifecycle", "--- 生命周期对比 ---")
        
        createObjectsAndObserveLifecycle()
        
        // 建议GC运行（实际项目中不推荐）
        System.gc()
        Thread.sleep(1000)  // 等待GC完成
        
        val runtime = Runtime.getRuntime()
        val afterGC = (runtime.totalMemory() - runtime.freeMemory()) / 1024
        Log.d("Lifecycle", "GC后堆内存使用: ${afterGC}KB")
        
        // 💡 观察要点：
        // 1. 方法结束后，局部对象引用（栈中）立即消失
        // 2. 但对象本身（堆中）可能还在，等待GC回收
        // 3. GC运行后，堆内存会下降
    }
    
    private fun createObjectsAndObserveLifecycle() {
        val tempObjects = Array(500) { User("Temp$it") }
        Log.d("Lifecycle", "临时创建500个对象，占用堆内存")
        
        // tempObjects引用存在栈中，User对象存在堆中
        // 方法结束时，栈中的引用消失，但堆中的对象还可能存在
    } // ← tempObjects引用消失，但User对象等待GC回收
}

// 简单的用户类，用于演示对象分配
data class User(val name: String) {
    val id: Long = System.currentTimeMillis()
    val data: ByteArray = ByteArray(1024) { it.toByte() }  // 1KB数据，方便观察内存变化
}
```

### 1.2 GC行为的实时观察

```kotlin
/**
 * 目标：观察Android ART的垃圾回收行为
 * 验证方法：Memory Profiler + Logcat
 */
class Level1_GCObservation : AppCompatActivity() {
    
    private val objectHolder = mutableListOf<Any>()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        Log.d("GC", "=== GC行为观察实验 ===")
        
        // 实验1：观察正常的GC触发
        observeNormalGC()
        
        // 实验2：观察大对象分配时的GC
        observeLargeObjectGC()
        
        // 实验3：观察内存压力下的GC
        observeMemoryPressureGC()
    }
    
    private fun observeNormalGC() {
        Log.d("GC", "--- 正常GC观察 ---")
        
        repeat(10) { round ->
            // 创建一批对象
            val batch = Array(100) { 
                User("Batch${round}_User$it").apply {
                    // 添加一些数据让对象更大
                    largeData = ByteArray(10 * 1024) { it.toByte() }  // 10KB
                }
            }
            
            objectHolder.addAll(batch)
            
            // 记录内存状态
            logMemoryState("Round $round")
            
            Thread.sleep(100)  // 短暂等待，给GC时间运行
        }
        
        // 💡 在Memory Profiler中观察：
        // 1. Java/Kotlin内存呈阶梯状增长
        // 2. 可能看到锯齿状的GC回收模式
        // 3. GC事件在时间轴上的分布
    }
    
    private fun observeLargeObjectGC() {
        Log.d("GC", "--- 大对象分配GC观察 ---")
        
        // 分配大对象通常会触发GC
        repeat(5) { index ->
            Log.d("GC", "分配大对象 $index")
            
            val beforeMemory = getCurrentMemoryUsage()
            
            // 分配5MB的大对象
            val largeObject = ByteArray(5 * 1024 * 1024) { it.toByte() }
            objectHolder.add(largeObject)
            
            val afterMemory = getCurrentMemoryUsage()
            
            Log.d("GC", "大对象分配前后内存: ${beforeMemory}KB -> ${afterMemory}KB")
            
            Thread.sleep(500)  // 等待观察GC
        }
        
        // 💡 观察要点：
        // 1. 大对象分配可能立即触发GC
        // 2. 在Memory Profiler中看到突然的内存增长和可能的GC事件
    }
    
    private fun observeMemoryPressureGC() {
        Log.d("GC", "--- 内存压力GC观察 ---")
        
        try {
            // 持续分配内存直到触发频繁GC
            var counter = 0
            while (counter < 1000) {  // 限制循环次数，避免OOM
                val objects = Array(50) { 
                    ByteArray(100 * 1024) { it.toByte() }  // 每个100KB
                }
                objectHolder.addAll(objects)
                
                counter++
                
                if (counter % 10 == 0) {
                    logMemoryState("压力测试 Round $counter")
                    
                    // 检查是否接近内存限制
                    if (isNearingMemoryLimit()) {
                        Log.d("GC", "接近内存限制，停止分配")
                        break
                    }
                }
                
                Thread.sleep(50)
            }
        } catch (e: OutOfMemoryError) {
            Log.e("GC", "内存溢出: ${e.message}")
        }
        
        // 💡 观察要点：
        // 1. 内存压力增大时，GC会更频繁运行
        // 2. GC耗时可能增加（Stop-The-World时间）
        // 3. 应用可能出现卡顿
    }
    
    private fun logMemoryState(tag: String) {
        val runtime = Runtime.getRuntime()
        val totalMemory = runtime.totalMemory() / 1024
        val freeMemory = runtime.freeMemory() / 1024
        val usedMemory = totalMemory - freeMemory
        val maxMemory = runtime.maxMemory() / 1024
        
        Log.d("GC", "$tag - 使用: ${usedMemory}KB, 总计: ${totalMemory}KB, 最大: ${maxMemory}KB")
    }
    
    private fun getCurrentMemoryUsage(): Long {
        val runtime = Runtime.getRuntime()
        return (runtime.totalMemory() - runtime.freeMemory()) / 1024
    }
    
    private fun isNearingMemoryLimit(): Boolean {
        val runtime = Runtime.getRuntime()
        val usedMemory = runtime.totalMemory() - runtime.freeMemory()
        val maxMemory = runtime.maxMemory()
        
        return (usedMemory.toDouble() / maxMemory) > 0.8  // 使用超过80%
    }
}

// 扩展User类以支持大数据
data class User(val name: String) {
    val id: Long = System.currentTimeMillis()
    var largeData: ByteArray = ByteArray(0)
}
```

---

## 第2级：内存分配位置验证（进阶理解）

### 2.1 三层堆结构的实际验证

```kotlin
/**
 * 目标：验证进程堆段、Native堆、ART堆的三层结构
 * 验证方法：Memory Profiler + dumpsys meminfo
 */
class Level2_ThreeLayerHeap : AppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        Log.d("ThreeLayer", "=== 三层堆结构验证 ===")
        
        // 验证1：ART Java堆分配
        verifyARTHeapAllocation()
        
        // 验证2：Native堆分配
        verifyNativeHeapAllocation()
        
        // 验证3：对比Android 8前后的图片内存分配
        verifyBitmapMemoryLocation()
    }
    
    private fun verifyARTHeapAllocation() {
        Log.d("ThreeLayer", "--- ART Java堆验证 ---")
        
        val memInfo = Debug.MemoryInfo()
        
        // 记录分配前状态
        Debug.getMemoryInfo(memInfo)
        val javaHeapBefore = memInfo.dalvikHeap
        val runtimeBefore = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()
        
        Log.d("ThreeLayer", "分配前 - dalvikHeap: ${javaHeapBefore}KB, Runtime: ${runtimeBefore/1024}KB")
        
        // 大量分配Java对象
        val javaObjects = Array(2000) { index ->
            User("JavaUser$index").apply {
                // 每个对象包含一些数据，便于观察
                extraData = "This is extra data for user $index".repeat(10)
            }
        }
        
        // 记录分配后状态
        Thread.sleep(1000)  // 等待内存统计更新
        Debug.getMemoryInfo(memInfo)
        val javaHeapAfter = memInfo.dalvikHeap
        val runtimeAfter = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()
        
        Log.d("ThreeLayer", "分配后 - dalvikHeap: ${javaHeapAfter}KB, Runtime: ${runtimeAfter/1024}KB")
        Log.d("ThreeLayer", "Java堆增长: ${javaHeapAfter - javaHeapBefore}KB")
        
        // 💡 验证要点：
        // 1. dalvikHeap（ART堆）显著增长
        // 2. Runtime统计也相应增长
        // 3. 在Memory Profiler中Java/Kotlin柱状图增长
        
        // 保持引用，防止GC回收影响测试
        Log.d("ThreeLayer", "创建的Java对象数量: ${javaObjects.size}")
    }
    
    private fun verifyNativeHeapAllocation() {
        Log.d("ThreeLayer", "--- Native堆验证 ---")
        
        val memInfo = Debug.MemoryInfo()
        
        // 记录分配前状态
        Debug.getMemoryInfo(memInfo)
        val nativeHeapBefore = memInfo.nativeHeap
        
        Log.d("ThreeLayer", "Native堆分配前: ${nativeHeapBefore}KB")
        
        // 通过Bitmap分配Native内存（Android 8+）
        val bitmaps = mutableListOf<Bitmap>()
        repeat(10) { index ->
            // 创建大图片，像素数据存在Native堆中
            val bitmap = Bitmap.createBitmap(1024, 1024, Bitmap.Config.ARGB_8888)
            
            // 填充一些数据，确保内存真正分配
            val canvas = Canvas(bitmap)
            canvas.drawColor(Color.rgb(index * 25, 128, 255 - index * 25))
            
            bitmaps.add(bitmap)
            
            Log.d("ThreeLayer", "创建第${index + 1}个Bitmap (1024x1024)")
        }
        
        // 记录分配后状态
        Thread.sleep(1000)
        Debug.getMemoryInfo(memInfo)
        val nativeHeapAfter = memInfo.nativeHeap
        
        Log.d("ThreeLayer", "Native堆分配后: ${nativeHeapAfter}KB")
        Log.d("ThreeLayer", "Native堆增长: ${nativeHeapAfter - nativeHeapBefore}KB")
        
        // 💡 验证要点：
        // 1. nativeHeap显著增长（约40MB，10个4MB的ARGB图片）
        // 2. 在Memory Profiler中Native柱状图增长
        // 3. Java/Kotlin堆仅有少量增长（Bitmap对象本身）
        
        // 计算理论像素数据大小
        val expectedPixelData = 10 * 1024 * 1024 * 4 / 1024  // 10张图片，每张4MB
        Log.d("ThreeLayer", "预期像素数据大小: ${expectedPixelData}KB")
        
        // 保持Bitmap引用，防止Native内存被回收
        Log.d("ThreeLayer", "创建的Bitmap数量: ${bitmaps.size}")
    }
    
    private fun verifyBitmapMemoryLocation() {
        Log.d("ThreeLayer", "--- 图片内存位置验证 ---")
        
        val memInfo = Debug.MemoryInfo()
        
        // 记录基准状态
        Debug.getMemoryInfo(memInfo)
        val baselineJava = memInfo.dalvikHeap
        val baselineNative = memInfo.nativeHeap
        
        Log.d("ThreeLayer", "基准 - Java: ${baselineJava}KB, Native: ${baselineNative}KB")
        
        // 加载一张大图片
        val largeBitmap = BitmapFactory.decodeResource(resources, R.drawable.large_sample)
        
        Thread.sleep(1000)
        Debug.getMemoryInfo(memInfo)
        val afterJava = memInfo.dalvikHeap
        val afterNative = memInfo.nativeHeap
        
        val javaGrowth = afterJava - baselineJava
        val nativeGrowth = afterNative - baselineNative
        
        Log.d("ThreeLayer", "加载大图后 - Java增长: ${javaGrowth}KB, Native增长: ${nativeGrowth}KB")
        
        // 分析结果
        if (nativeGrowth > javaGrowth * 5) {  // Native增长远大于Java增长
            Log.d("ThreeLayer", "✓ 验证成功：图片像素数据存储在Native堆中（Android 8+特性）")
        } else if (javaGrowth > nativeGrowth * 5) {
            Log.d("ThreeLayer", "ⓘ 检测到：图片像素数据存储在Java堆中（Android 7及之前特性）")
        } else {
            Log.d("ThreeLayer", "? 内存分配模式不明确，可能需要更大的图片进行测试")
        }
        
        // 💡 验证要点：
        // Android 8+: nativeHeap显著增长，dalvikHeap小幅增长
        // Android 7-: dalvikHeap显著增长，nativeHeap小幅增长
        
        // 打印图片信息
        largeBitmap?.let { bitmap ->
            val pixelBytes = bitmap.width * bitmap.height * 4  // ARGB每像素4字节
            Log.d("ThreeLayer", "图片信息: ${bitmap.width}x${bitmap.height}, 像素数据约${pixelBytes/1024}KB")
        }
    }
}

// 扩展User类
data class User(val name: String) {
    val id: Long = System.currentTimeMillis()
    var extraData: String = ""
}
```

### 2.2 内存映射和虚拟地址空间探索

```kotlin
/**
 * 目标：理解进程虚拟地址空间和内存映射
 * 验证方法：/proc/[pid]/maps + 自定义分析
 */
class Level2_VirtualMemoryExplorer : AppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        Log.d("VirtualMemory", "=== 虚拟内存空间探索 ===")
        
        // 探索1：分析当前进程的内存映射
        analyzeProcessMemoryMaps()
        
        // 探索2：观察内存分配对地址空间的影响
        observeMemoryAllocationEffect()
        
        // 探索3：理解共享库的内存映射
        analyzeSharedLibraryMapping()
    }
    
    private fun analyzeProcessMemoryMaps() {
        Log.d("VirtualMemory", "--- 进程内存映射分析 ---")
        
        val processId = android.os.Process.myPid()
        Log.d("VirtualMemory", "当前进程ID: $processId")
        
        // 💡 手动执行以下命令来查看内存映射：
        // adb shell cat /proc/$processId/maps
        
        Log.d("VirtualMemory", """
            |💡 请手动执行以下命令查看内存映射：
            |adb shell cat /proc/$processId/maps
            |
            |关键映射区域说明：
            |[heap] - 进程主堆段
            |[anon:libc_malloc] - Native堆的匿名内存区域
            |[anon:dalvik-main space] - ART虚拟机主堆空间
            |[stack] - 主线程栈
            |libxxx.so - 各种动态链接库
        """.trimMargin())
        
        // 创建一些对象，然后再次查看映射变化
        createObjectsForMappingObservation()
        
        Log.d("VirtualMemory", """
            |💡 现在再次执行命令，观察内存映射的变化：
            |adb shell cat /proc/$processId/maps | grep -E "(heap|dalvik|malloc)"
        """.trimMargin())
    }
    
    private fun createObjectsForMappingObservation() {
        Log.d("VirtualMemory", "创建对象以观察内存映射变化...")
        
        // 创建大量Java对象
        val javaObjects = Array(1000) { User("MapUser$it") }
        
        // 创建Bitmap以分配Native内存
        val bitmap = Bitmap.createBitmap(2048, 2048, Bitmap.Config.ARGB_8888)
        
        // 分配大量Native内存（如果有JNI代码）
        // val nativeBuffer = allocateNativeMemory(10 * 1024 * 1024)  // 10MB
        
        Log.d("VirtualMemory", "对象创建完成，Java对象: ${javaObjects.size}, Bitmap: ${bitmap.width}x${bitmap.height}")
    }
    
    private fun observeMemoryAllocationEffect() {
        Log.d("VirtualMemory", "--- 观察内存分配对地址空间的影响 ---")
        
        // 记录分配前的状态
        logVirtualMemoryUsage("分配前")
        
        // 阶段1：分配Java对象
        val phase1Objects = Array(500) { User("Phase1_$it") }
        logVirtualMemoryUsage("Java对象分配后")
        
        // 阶段2：分配Bitmap
        val phase2Bitmaps = Array(5) { 
            Bitmap.createBitmap(1024, 1024, Bitmap.Config.ARGB_8888)
        }
        logVirtualMemoryUsage("Bitmap分配后")
        
        // 阶段3：分配大数组
        val phase3Arrays = Array(10) { ByteArray(1024 * 1024) }  // 每个1MB
        logVirtualMemoryUsage("大数组分配后")
        
        // 💡 观察要点：
        // 1. 虚拟内存大小的变化
        // 2. 物理内存使用的变化
        // 3. 不同类型分配对内存统计的影响
        
        // 保持引用，防止GC影响观察
        Log.d("VirtualMemory", "保持引用 - Java: ${phase1Objects.size}, Bitmap: ${phase2Bitmaps.size}, Array: ${phase3Arrays.size}")
    }
    
    private fun logVirtualMemoryUsage(phase: String) {
        try {
            val processId = android.os.Process.myPid()
            val statusFile = File("/proc/$processId/status")
            
            if (statusFile.exists() && statusFile.canRead()) {
                val lines = statusFile.readLines()
                val vmSize = lines.find { it.startsWith("VmSize:") }?.substringAfter("VmSize:")?.trim()
                val vmRSS = lines.find { it.startsWith("VmRSS:") }?.substringAfter("VmRSS:")?.trim()
                val vmPeak = lines.find { it.startsWith("VmPeak:") }?.substringAfter("VmPeak:")?.trim()
                
                Log.d("VirtualMemory", """
                    |$phase:
                    |  虚拟内存大小: $vmSize
                    |  物理内存使用: $vmRSS  
                    |  虚拟内存峰值: $vmPeak
                """.trimMargin())
            } else {
                Log.w("VirtualMemory", "无法读取 /proc/$processId/status")
            }
        } catch (e: Exception) {
            Log.e("VirtualMemory", "读取虚拟内存信息失败: ${e.message}")
        }
        
        // 备用方法：使用ActivityManager获取内存信息
        val activityManager = getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
        val memInfo = ActivityManager.MemoryInfo()
        activityManager.getMemoryInfo(memInfo)
        
        Log.d("VirtualMemory", """
            |$phase (系统内存):
            |  可用内存: ${memInfo.availMem / 1024 / 1024}MB
            |  总内存: ${memInfo.totalMem / 1024 / 1024}MB
            |  内存不足: ${memInfo.lowMemory}
        """.trimMargin())
    }
    
    private fun analyzeSharedLibraryMapping() {
        Log.d("VirtualMemory", "--- 共享库内存映射分析 ---")
        
        val processId = android.os.Process.myPid()
        
        Log.d("VirtualMemory", """
            |💡 执行以下命令分析共享库映射：
            |adb shell cat /proc/$processId/maps | grep "\.so"
            |
            |观察要点：
            |1. libart.so - ART虚拟机库
            |2. libc.so - C标准库
            |3. libdl.so - 动态加载库
            |4. 应用相关的.so文件
            |
            |共享库的特点：
            |- 多个进程可以共享同一份库的代码段
            |- 数据段是进程私有的
            |- 通过Copy-On-Write机制优化内存使用
        """.trimMargin())
        
        // 如果应用有JNI库，可以触发加载
        try {
            // System.loadLibrary("your_native_lib")
            Log.d("VirtualMemory", "如果有JNI库，此处会触发库加载和内存映射")
        } catch (e: Exception) {
            Log.d("VirtualMemory", "没有JNI库需要加载")
        }
    }
}
```

---

## 第3级：内存问题诊断与优化（高级应用）

### 3.1 内存泄漏的创建、检测和修复

```kotlin
/**
 * 目标：创建真实的内存泄漏场景，学习检测和修复方法
 * 验证方法：LeakCanary + Memory Profiler + MAT
 */
class Level3_MemoryLeakDemo : AppCompatActivity() {
    
    companion object {
        // 静态引用，可能导致内存泄漏
        private val staticActivityRefs = mutableListOf<Activity>()
        private var staticHandler: Handler? = null
    }
    
    // 匿名内部类，持有外部类引用
    private val problemHandler = Handler(Looper.getMainLooper())
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        Log.d("MemoryLeak", "=== 内存泄漏演示与修复 ===")
        
        // 泄漏场景1：静态引用持有Activity
        demonstrateStaticReferenceLeak()
        
        // 泄漏场景2：Handler延迟消息
        demonstrateHandlerLeak()
        
        // 泄漏场景3：监听器未注销
        demonstrateListenerLeak()
        
        // 泄漏场景4：非静态内部类
        demonstrateInnerClassLeak()
        
        // 修复演示
        demonstrateLeakFixes()
    }
    
    private fun demonstrateStaticReferenceLeak() {
        Log.d("MemoryLeak", "--- 场景1：静态引用泄漏 ---")
        
        // ❌ 错误做法：静态引用持有Activity
        staticActivityRefs.add(this)  // 这会导致Activity无法被GC回收
        
        Log.d("MemoryLeak", "已添加Activity到静态列表，当前数量: ${staticActivityRefs.size}")
        
        // 💡 检测方法：
        // 1. 使用LeakCanary自动检测
        // 2. 在Memory Profiler中捕获heap dump，查看Activity实例数量
        // 3. 多次旋转屏幕或重启Activity，观察Activity实例是否增长
        
        // 模拟修复：在合适的时机清理引用
        // staticActivityRefs.removeAll { it is Level3_MemoryLeakDemo }
    }
    
    private fun demonstrateHandlerLeak() {
        Log.d("MemoryLeak", "--- 场景2：Handler消息泄漏 ---")
        
        // ❌ 错误做法：匿名内部类Handler + 长延迟消息
        problemHandler.postDelayed({
            // 这个Runnable是匿名内部类，持有Activity的隐式引用
            // 即使Activity被销毁，这个延迟消息仍然持有Activity引用
            Log.d("MemoryLeak", "延迟消息执行，但Activity可能已被销毁")
            updateUI()  // 隐式的this.updateUI()
        }, 30000)  // 30秒延迟，足够Activity被销毁多次
        
        // ❌ 更严重的做法：静态Handler
        if (staticHandler == null) {
            staticHandler = Handler(Looper.getMainLooper())
        }
        
        staticHandler?.postDelayed({
            // 静态Handler + 匿名Runnable，双重泄漏
            Log.d("MemoryLeak", "静态Handler执行延迟任务")
        }, 60000)  // 60秒延迟
        
        Log.d("MemoryLeak", "已发送长延迟消息，可能导致Activity泄漏")
        
        // 💡 检测方法：
        // 1. LeakCanary会检测到Handler消息队列持有Activity
        // 2. 在Memory Profiler中查看MessageQueue的引用链
    }
    
    private fun demonstrateListenerLeak() {
        Log.d("MemoryLeak", "--- 场景3：监听器未注销泄漏 ---")
        
        // ❌ 错误做法：注册监听器但不注销
        val sharedPrefs = getSharedPreferences("demo", Context.MODE_PRIVATE)
        val listener = SharedPreferences.OnSharedPreferenceChangeListener { prefs, key ->
            // 这个监听器持有Activity引用
            Log.d("MemoryLeak", "SharedPreferences changed: $key")
            // 可能访问Activity的方法或字段
            updateUI()
        }
        
        sharedPrefs.registerOnSharedPreferenceChangeListener(listener)
        
        // ❌ 忘记在onDestroy中注销监听器
        // sharedPrefs.unregisterOnSharedPreferenceChangeListener(listener)
        
        // 模拟其他类型的监听器泄漏
        registerBroadcastReceiver()  // BroadcastReceiver泄漏
        registerEventBusListener()  // EventBus泄漏
        
        Log.d("MemoryLeak", "已注册多个监听器，但未正确注销")
        
        // 💡 检测方法：
        // 1. LeakCanary能检测大部分监听器泄漏
        // 2. 手动分析heap dump中的监听器引用链
    }
    
    private fun demonstrateInnerClassLeak() {
        Log.d("MemoryLeak", "--- 场景4：非静态内部类泄漏 ---")
        
        // ❌ 错误做法：非静态内部类 + 异步任务
        val asyncTask = object : Thread() {
            override fun run() {
                try {
                    // 模拟长时间运行的任务
                    Thread.sleep(45000)  // 45秒
                    
                    // 非静态内部类隐式持有外部类引用
                    // 即使Activity被销毁，这个线程仍然持有Activity引用
                    Log.d("MemoryLeak", "异步任务完成")
                    
                    // 尝试访问外部Activity的方法（危险！）
                    post {
                        updateUI()  // 可能在Activity销毁后调用
                    }
                } catch (e: InterruptedException) {
                    Log.d("MemoryLeak", "异步任务被中断")
                }
            }
        }
        
        asyncTask.start()
        
        // ❌ 忘记在onDestroy中取消任务
        // asyncTask.interrupt()
        
        Log.d("MemoryLeak", "已启动长时间运行的异步任务")
    }
    
    private fun demonstrateLeakFixes() {
        Log.d("MemoryLeak", "--- 内存泄漏修复演示 ---")
        
        // ✅ 修复1：使用WeakReference
        fixStaticReferenceWithWeakRef()
        
        // ✅ 修复2：静态内部类 + WeakReference
        fixHandlerWithStaticInnerClass()
        
        // ✅ 修复3：生命周期管理
        demonstrateLifecycleManagement()
    }
    
    private fun fixStaticReferenceWithWeakRef() {
        Log.d("MemoryLeak", "✅ 修复：使用WeakReference替代强引用")
        
        // ✅ 正确做法：使用WeakReference包装Activity引用
        val weakActivityRef = WeakReference(this)
        
        // 如果需要静态持有，使用WeakReference
        StaticActivityHolder.addActivity(this)
        
        // 使用时检查引用是否还有效
        weakActivityRef.get()?.let { activity ->
            Log.d("MemoryLeak", "Activity仍然有效，可以安全使用")
        } ?: Log.d("MemoryLeak", "Activity已被回收")
    }
    
    private fun fixHandlerWithStaticInnerClass() {
        Log.d("MemoryLeak", "✅ 修复：静态内部类Handler + WeakReference")
        
        // ✅ 正确做法：使用静态内部类
        val safeHandler = SafeHandler(this)
        safeHandler.sendMessageDelayed(Message.obtain(safeHandler, MSG_UPDATE_UI), 30000)
        
        Log.d("MemoryLeak", "使用安全的Handler发送延迟消息")
    }
    
    private fun demonstrateLifecycleManagement() {
        Log.d("MemoryLeak", "✅ 修复：正确的生命周期管理")
        
        // ✅ 正确做法：与生命周期绑定的资源管理
        lifecycle.addObserver(object : DefaultLifecycleObserver {
            override fun onDestroy(owner: LifecycleOwner) {
                Log.d("MemoryLeak", "Activity销毁，清理所有资源")
                
                // 清理Handler消息
                problemHandler.removeCallbacksAndMessages(null)
                staticHandler?.removeCallbacksAndMessages(null)
                
                // 清理监听器
                cleanupListeners()
                
                // 清理静态引用
                staticActivityRefs.clear()
                
                super.onDestroy(owner)
            }
        })
    }
    
    private fun updateUI() {
        // 模拟UI更新操作
        Log.d("MemoryLeak", "UI更新操作")
    }
    
    private fun registerBroadcastReceiver() {
        // 模拟注册BroadcastReceiver
        Log.d("MemoryLeak", "注册BroadcastReceiver（演示用）")
    }
    
    private fun registerEventBusListener() {
        // 模拟注册EventBus监听器
        Log.d("MemoryLeak", "注册EventBus监听器（演示用）")
    }
    
    private fun cleanupListeners() {
        Log.d("MemoryLeak", "清理所有监听器")
        // 实际项目中在这里清理所有注册的监听器
    }
    
    // ✅ 正确的Handler实现
    class SafeHandler(activity: Level3_MemoryLeakDemo) : Handler(Looper.getMainLooper()) {
        private val activityRef = WeakReference(activity)
        
        override fun handleMessage(msg: Message) {
            val activity = activityRef.get()
            if (activity != null && !activity.isFinishing && !activity.isDestroyed) {
                when (msg.what) {
                    MSG_UPDATE_UI -> {
                        activity.updateUI()
                        Log.d("MemoryLeak", "安全Handler执行UI更新")
                    }
                }
            } else {
                Log.d("MemoryLeak", "Activity已销毁，取消Handler消息执行")
            }
        }
    }
    
    companion object {
        private const val MSG_UPDATE_UI = 1001
    }
}

// ✅ 安全的静态Activity持有者
object StaticActivityHolder {
    private val activityRefs = mutableListOf<WeakReference<Activity>>()
    
    fun addActivity(activity: Activity) {
        // 清理已回收的引用
        activityRefs.removeAll { it.get() == null }
        
        // 添加新的弱引用
        activityRefs.add(WeakReference(activity))
        
        Log.d("StaticHolder", "当前持有Activity数量: ${activityRefs.size}")
    }
    
    fun getActiveActivities(): List<Activity> {
        return activityRefs.mapNotNull { it.get() }
    }
}
```

### 3.2 性能优化综合实践

```kotlin
/**
 * 目标：综合应用内存管理知识进行性能优化
 * 验证方法：性能对比测试 + Memory Profiler
 */
class Level3_PerformanceOptimization : AppCompatActivity() {
    
    // 对象池
    private val bitmapPool = BitmapPool()
    private val stringBuilderPool = ObjectPool<StringBuilder> { StringBuilder() }
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        Log.d("Optimization", "=== 内存性能优化综合实践 ===")
        
        // 优化1：对象复用 vs 频繁创建
        compareObjectReuse()
        
        // 优化2：内存缓存优化
        demonstrateMemoryCache()
        
        // 优化3：图片内存优化
        demonstrateBitmapOptimization()
        
        // 优化4：字符串操作优化
        demonstrateStringOptimization()
    }
    
    private fun compareObjectReuse() {
        Log.d("Optimization", "--- 对象复用 vs 频繁创建对比 ---")
        
        val iterations = 1000
        
        // 测试1：频繁创建对象（不推荐）
        val startTime1 = System.currentTimeMillis()
        val startMemory1 = getCurrentMemoryUsage()
        
        repeat(iterations) {
            // 每次都创建新的StringBuilder
            val sb = StringBuilder()
            sb.append("Item $it")
            val result = sb.toString()
            // sb对象变为垃圾，等待GC回收
        }
        
        val endTime1 = System.currentTimeMillis()
        val endMemory1 = getCurrentMemoryUsage()
        
        Log.d("Optimization", """
            |频繁创建模式:
            |  耗时: ${endTime1 - startTime1}ms
            |  内存增长: ${endMemory1 - startMemory1}KB
        """.trimMargin())
        
        // 手动触发GC，清理垃圾对象
        System.gc()
        Thread.sleep(1000)
        
        // 测试2：对象复用模式（推荐）
        val startTime2 = System.currentTimeMillis()
        val startMemory2 = getCurrentMemoryUsage()
        
        repeat(iterations) {
            // 从对象池获取StringBuilder
            val sb = stringBuilderPool.acquire()
            sb.clear()  // 清空之前的内容
            sb.append("Item $it")
            val result = sb.toString()
            stringBuilderPool.release(sb)  // 归还给对象池
        }
        
        val endTime2 = System.currentTimeMillis()
        val endMemory2 = getCurrentMemoryUsage()
        
        Log.d("Optimization", """
            |对象复用模式:
            |  耗时: ${endTime2 - startTime2}ms  
            |  内存增长: ${endMemory2 - startMemory2}KB
            |
            |性能改善:
            |  速度提升: ${((endTime1 - startTime1) - (endTime2 - startTime2))}ms
            |  内存节约: ${(endMemory1 - startMemory1) - (endMemory2 - startMemory2)}KB
        """.trimMargin())
        
        // 💡 在Memory Profiler中观察：
        // 1. 对象复用模式的GC事件更少
        // 2. 内存分配速率更低
        // 3. 内存使用更平稳
    }
    
    private fun demonstrateMemoryCache() {
        Log.d("Optimization", "--- 内存缓存优化 ---")
        
        // 创建LRU缓存
        val maxMemory = (Runtime.getRuntime().maxMemory() / 1024).toInt()
        val cacheSize = maxMemory / 8  // 使用可用内存的1/8作为缓存
        
        val imageCache = object : LruCache<String, Bitmap>(cacheSize) {
            override fun sizeOf(key: String, bitmap: Bitmap): Int {
                // 返回Bitmap的大小（KB）
                return bitmap.byteCount / 1024
            }
            
            override fun entryRemoved(evicted: Boolean, key: String, oldValue: Bitmap, newValue: Bitmap?) {
                Log.d("Cache", "缓存条目移除: $key, 被驱逐: $evicted")
                // 可以在这里回收Bitmap到对象池
                if (evicted && !oldValue.isRecycled) {
                    bitmapPool.recycleBitmap(oldValue)
                }
            }
        }
        
        Log.d("Optimization", "创建图片缓存，大小: ${cacheSize}KB")
        
        // 测试缓存效果
        val testImages = arrayOf("image1", "image2", "image3", "image1", "image2")  // 重复访问
        
        testImages.forEachIndexed { index, imageName ->
            val startTime = System.currentTimeMillis()
            
            var bitmap = imageCache.get(imageName)
            if (bitmap == null) {
                // 缓存未命中，创建新图片
                bitmap = createSampleBitmap(imageName)
                imageCache.put(imageName, bitmap)
                Log.d("Cache", "缓存未命中，创建图片: $imageName")
            } else {
                Log.d("Cache", "缓存命中: $imageName")
            }
            
            val endTime = System.currentTimeMillis()
            Log.d("Cache", "第${index + 1}次访问$imageName，耗时: ${endTime - startTime}ms")
        }
        
        // 打印缓存统计
        Log.d("Cache", """
            |缓存统计:
            |  命中次数: ${imageCache.hitCount()}
            |  未命中次数: ${imageCache.missCount()}
            |  命中率: ${imageCache.hitCount() * 100 / (imageCache.hitCount() + imageCache.missCount())}%
            |  当前大小: ${imageCache.size()}KB
        """.trimMargin())
    }
    
    private fun demonstrateBitmapOptimization() {
        Log.d("Optimization", "--- 图片内存优化 ---")
        
        // 优化1：正确的采样率计算
        val options = BitmapFactory.Options()
        
        // 首先只获取图片尺寸，不加载像素数据
        options.inJustDecodeBounds = true
        BitmapFactory.decodeResource(resources, R.drawable.sample_large_image, options)
        
        val imageWidth = options.outWidth
        val imageHeight = options.outHeight
        Log.d("Optimization", "原始图片尺寸: ${imageWidth}x${imageHeight}")
        
        // 目标显示尺寸
        val targetWidth = 512
        val targetHeight = 512
        
        // 计算合适的采样率
        val sampleSize = calculateInSampleSize(options, targetWidth, targetHeight)
        
        // 实际加载图片
        options.inJustDecodeBounds = false
        options.inSampleSize = sampleSize
        options.inPreferredConfig = Bitmap.Config.RGB_565  // 使用RGB_565减少内存使用
        
        val optimizedBitmap = BitmapFactory.decodeResource(resources, R.drawable.sample_large_image, options)
        
        optimizedBitmap?.let { bitmap ->
            val memoryUsage = bitmap.byteCount / 1024
            Log.d("Optimization", """
                |图片优化结果:
                |  采样率: $sampleSize
                |  优化后尺寸: ${bitmap.width}x${bitmap.height}
                |  内存使用: ${memoryUsage}KB
                |  配置: ${bitmap.config}
            """.trimMargin())
            
            // 优化2：使用对象池复用Bitmap
            val reusedBitmap = bitmapPool.getBitmap(bitmap.width, bitmap.height, bitmap.config)
            Log.d("Optimization", "从对象池${if (reusedBitmap != null) "获取" else "创建"}Bitmap")
        }
    }
    
    private fun demonstrateStringOptimization() {
        Log.d("Optimization", "--- 字符串操作优化 ---")
        
        val iterations = 1000
        
        // 测试1：String拼接（低效）
        val startTime1 = System.currentTimeMillis()
        val startMemory1 = getCurrentMemoryUsage()
        
        var result1 = ""
        repeat(iterations) {
            result1 += "Item $it, "  // 每次都创建新的String对象
        }
        
        val endTime1 = System.currentTimeMillis()
        val endMemory1 = getCurrentMemoryUsage()
        
        // 测试2：StringBuilder（高效）
        val startTime2 = System.currentTimeMillis()
        val startMemory2 = getCurrentMemoryUsage()
        
        val sb = StringBuilder()
        repeat(iterations) {
            sb.append("Item $it, ")
        }
        val result2 = sb.toString()
        
        val endTime2 = System.currentTimeMillis()
        val endMemory2 = getCurrentMemoryUsage()
        
        Log.d("Optimization", """
            |字符串操作对比:
            |String拼接:
            |  耗时: ${endTime1 - startTime1}ms
            |  内存增长: ${endMemory1 - startMemory1}KB
            |
            |StringBuilder:
            |  耗时: ${endTime2 - startTime2}ms
            |  内存增长: ${endMemory2 - startMemory2}KB
            |
            |性能差异:
            |  速度提升: ${(endTime1 - startTime1) - (endTime2 - startTime2)}ms
            |  内存节约: ${(endMemory1 - startMemory1) - (endMemory2 - startMemory2)}KB
        """.trimMargin())
    }
    
    // 工具方法
    private fun getCurrentMemoryUsage(): Long {
        val runtime = Runtime.getRuntime()
        return (runtime.totalMemory() - runtime.freeMemory()) / 1024
    }
    
    private fun createSampleBitmap(name: String): Bitmap {
        // 创建示例图片
        val bitmap = Bitmap.createBitmap(256, 256, Bitmap.Config.ARGB_8888)
        val canvas = Canvas(bitmap)
        val paint = Paint().apply {
            textSize = 32f
            color = Color.WHITE
        }
        canvas.drawColor(Color.BLUE)
        canvas.drawText(name, 50f, 128f, paint)
        return bitmap
    }
    
    private fun calculateInSampleSize(options: BitmapFactory.Options, reqWidth: Int, reqHeight: Int): Int {
        val height = options.outHeight
        val width = options.outWidth
        var inSampleSize = 1
        
        if (height > reqHeight || width > reqWidth) {
            val halfHeight = height / 2
            val halfWidth = width / 2
            
            while ((halfHeight / inSampleSize) >= reqHeight && (halfWidth / inSampleSize) >= reqWidth) {
                inSampleSize *= 2
            }
        }
        
        return inSampleSize
    }
}

// 通用对象池实现
class ObjectPool<T>(private val factory: () -> T) {
    private val pool = mutableListOf<T>()
    private val maxSize = 10
    
    fun acquire(): T {
        return if (pool.isNotEmpty()) {
            pool.removeAt(pool.size - 1)
        } else {
            factory()
        }
    }
    
    fun release(obj: T) {
        if (pool.size < maxSize) {
            pool.add(obj)
        }
    }
}

// Bitmap对象池
class BitmapPool {
    private val pool = mutableMapOf<String, MutableList<Bitmap>>()
    
    fun getBitmap(width: Int, height: Int, config: Bitmap.Config): Bitmap? {
        val key = "${width}x${height}_$config"
        val bitmaps = pool[key]
        
        return if (bitmaps?.isNotEmpty() == true) {
            bitmaps.removeAt(bitmaps.size - 1)
        } else {
            null
        }
    }
    
    fun recycleBitmap(bitmap: Bitmap) {
        if (!bitmap.isRecycled) {
            val key = "${bitmap.width}x${bitmap.height}_${bitmap.config}"
            pool.getOrPut(key) { mutableListOf() }.add(bitmap)
        }
    }
}
```

## 🎓 总结与进阶指南

通过这些渐进式的代码示例，Java开发者可以：

1. **第1级**：建立基础概念，理解堆栈差异和GC行为
2. **第2级**：深入理解内存分配位置和虚拟内存映射
3. **第3级**：掌握实际的内存问题诊断和性能优化技能

每个示例都包含了详细的验证方法和观察要点，结合Memory Profiler等工具，可以让学习者在实际操作中深入理解Android内存管理机制。