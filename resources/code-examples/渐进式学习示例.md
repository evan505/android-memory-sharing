# æ¸è¿›å¼Androidå†…å­˜å­¦ä¹ ä»£ç ç¤ºä¾‹

## æ¦‚è¿°

è¿™ä¸ªæ–‡ä»¶æä¾›äº†ä¸€å¥—å®Œæ•´çš„ã€æ¸è¿›å¼çš„ä»£ç ç¤ºä¾‹ï¼Œå¸®åŠ©Javaå¼€å‘è€…ä»åŸºç¡€æ¦‚å¿µé€æ­¥æ·±å…¥åˆ°Androidå†…å­˜ç®¡ç†çš„å„ä¸ªå±‚é¢ã€‚æ¯ä¸ªç¤ºä¾‹éƒ½åŒ…å«è¯¦ç»†çš„æ³¨é‡Šå’ŒéªŒè¯æ–¹æ³•ã€‚

---

## ç¬¬1çº§ï¼šåŸºç¡€æ¦‚å¿µéªŒè¯ï¼ˆJavaå¼€å‘è€…èµ·ç‚¹ï¼‰

### 1.1 å †å†…å­˜ vs æ ˆå†…å­˜çš„ç›´è§‚å¯¹æ¯”

```kotlin
/**
 * ç›®æ ‡ï¼šè®©Javaå¼€å‘è€…ç›´è§‚ç†è§£å †æ ˆå·®å¼‚
 * éªŒè¯æ–¹æ³•ï¼šä½¿ç”¨Memory Profilerè§‚å¯Ÿå†…å­˜å˜åŒ–
 */
class Level1_HeapVsStack : AppCompatActivity() {
    
    // å…¨å±€å˜é‡ï¼šå­˜å‚¨åœ¨æ•°æ®æ®µï¼ˆä¸æ˜¯å †ä¹Ÿä¸æ˜¯æ ˆï¼‰
    companion object {
        private const val GLOBAL_CONSTANT = "æˆ‘åœ¨æ•°æ®æ®µ"
        private var globalCounter = 0
    }
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        Log.d("Level1", "=== å¼€å§‹åŸºç¡€å†…å­˜æ¦‚å¿µéªŒè¯ ===")
        
        // éªŒè¯1ï¼šæ ˆå†…å­˜çš„ç‰¹ç‚¹
        demonstrateStackMemory()
        
        // éªŒè¯2ï¼šå †å†…å­˜çš„ç‰¹ç‚¹  
        demonstrateHeapMemory()
        
        // éªŒè¯3ï¼šå¯¹æ¯”ä¸¤è€…çš„ç”Ÿå‘½å‘¨æœŸ
        compareLifecycles()
    }
    
    private fun demonstrateStackMemory() {
        Log.d("Stack", "--- æ ˆå†…å­˜æ¼”ç¤º ---")
        
        // ğŸ“š æ ˆå†…å­˜ç‰¹ç‚¹ï¼š
        // 1. å±€éƒ¨å˜é‡å­˜åœ¨æ ˆä¸­
        // 2. æ–¹æ³•è°ƒç”¨ç»“æŸï¼Œæ ˆä¸­æ•°æ®è‡ªåŠ¨æ¸…ç†
        // 3. é€Ÿåº¦å¿«ï¼Œå¤§å°æœ‰é™
        
        val stackVariable1 = 42  // intç±»å‹ï¼Œå­˜åœ¨æ ˆä¸­
        val stackVariable2 = "Hello"  // å¼•ç”¨å­˜åœ¨æ ˆä¸­ï¼Œ"Hello"å¯¹è±¡åœ¨å †ä¸­
        
        Log.d("Stack", "å±€éƒ¨å˜é‡åˆ›å»º: $stackVariable1, $stackVariable2")
        
        // é€’å½’è°ƒç”¨æ¼”ç¤ºæ ˆçš„å¢é•¿
        recursiveStackDemo(5)
        
        // ğŸ’¡ éªŒè¯æ–¹æ³•ï¼š
        // åœ¨Memory Profilerä¸­è§‚å¯ŸStackå†…å­˜çš„å˜åŒ–
        // æ³¨æ„ï¼šå±€éƒ¨å˜é‡æœ¬èº«å¾ˆå°ï¼Œä¸»è¦è§‚å¯Ÿæ–¹æ³•è°ƒç”¨çš„æ ˆå¸§
        
    } // â† æ–¹æ³•ç»“æŸï¼ŒstackVariable1å’ŒstackVariable2çš„æ ˆç©ºé—´è‡ªåŠ¨é‡Šæ”¾
    
    private fun recursiveStackDemo(depth: Int) {
        val localArray = IntArray(100) { it }  // æ¯å±‚é€’å½’åˆ†é…400å­—èŠ‚æ ˆç©ºé—´
        
        Log.d("Stack", "é€’å½’æ·±åº¦: $depth, æ•°ç»„å¤§å°: ${localArray.size}")
        
        if (depth > 1) {
            recursiveStackDemo(depth - 1)  // ç»§ç»­é€’å½’ï¼Œæ ˆç»§ç»­å¢é•¿
        }
        
        // ğŸ’¡ è§‚å¯Ÿè¦ç‚¹ï¼š
        // 1. æ¯æ¬¡é€’å½’éƒ½ä¼šåœ¨æ ˆä¸­åˆ›å»ºæ–°çš„localArray
        // 2. é€’å½’è¿”å›æ—¶ï¼Œæ ˆç©ºé—´ä¼šè‡ªåŠ¨å›æ”¶
        // 3. åœ¨Memory Profilerä¸­Stackå†…å­˜ä¼šéšé€’å½’æ·±åº¦å˜åŒ–
    }
    
    private fun demonstrateHeapMemory() {
        Log.d("Heap", "--- å †å†…å­˜æ¼”ç¤º ---")
        
        // ğŸ“š å †å†…å­˜ç‰¹ç‚¹ï¼š
        // 1. å¯¹è±¡å­˜åœ¨å †ä¸­
        // 2. éœ€è¦GCå›æ”¶
        // 3. å¯ä»¥åœ¨æ–¹æ³•é—´ä¼ é€’
        // 4. å¤§å°çµæ´»ï¼Œä½†åˆ†é…è¾ƒæ…¢
        
        val objectList = mutableListOf<User>()  // Listå¯¹è±¡åœ¨å †ä¸­
        
        // åœ¨Memory Profilerä¸­è§‚å¯ŸJava/Kotlinå†…å­˜å¢é•¿
        repeat(1000) { index ->
            val user = User("User$index")  // æ¯ä¸ªUserå¯¹è±¡éƒ½åœ¨å †ä¸­åˆ†é…
            objectList.add(user)
            
            if (index % 200 == 0) {
                val runtime = Runtime.getRuntime()
                val usedMemory = (runtime.totalMemory() - runtime.freeMemory()) / 1024
                Log.d("Heap", "åˆ›å»º${index}ä¸ªå¯¹è±¡ï¼Œå †å†…å­˜ä½¿ç”¨: ${usedMemory}KB")
            }
        }
        
        // ğŸ’¡ éªŒè¯æ–¹æ³•ï¼š
        // 1. åœ¨Memory Profilerä¸­è§‚å¯ŸJava/KotlinæŸ±çŠ¶å›¾å¢é•¿
        // 2. å¯èƒ½çœ‹åˆ°GCäº‹ä»¶ï¼ˆé”¯é½¿çŠ¶ä¸‹é™ï¼‰
        // 3. å¯¹æ¯”åˆ›å»ºå¯¹è±¡å‰åçš„å†…å­˜ä½¿ç”¨é‡
    }
    
    private fun compareLifecycles() {
        Log.d("Lifecycle", "--- ç”Ÿå‘½å‘¨æœŸå¯¹æ¯” ---")
        
        createObjectsAndObserveLifecycle()
        
        // å»ºè®®GCè¿è¡Œï¼ˆå®é™…é¡¹ç›®ä¸­ä¸æ¨èï¼‰
        System.gc()
        Thread.sleep(1000)  // ç­‰å¾…GCå®Œæˆ
        
        val runtime = Runtime.getRuntime()
        val afterGC = (runtime.totalMemory() - runtime.freeMemory()) / 1024
        Log.d("Lifecycle", "GCåå †å†…å­˜ä½¿ç”¨: ${afterGC}KB")
        
        // ğŸ’¡ è§‚å¯Ÿè¦ç‚¹ï¼š
        // 1. æ–¹æ³•ç»“æŸåï¼Œå±€éƒ¨å¯¹è±¡å¼•ç”¨ï¼ˆæ ˆä¸­ï¼‰ç«‹å³æ¶ˆå¤±
        // 2. ä½†å¯¹è±¡æœ¬èº«ï¼ˆå †ä¸­ï¼‰å¯èƒ½è¿˜åœ¨ï¼Œç­‰å¾…GCå›æ”¶
        // 3. GCè¿è¡Œåï¼Œå †å†…å­˜ä¼šä¸‹é™
    }
    
    private fun createObjectsAndObserveLifecycle() {
        val tempObjects = Array(500) { User("Temp$it") }
        Log.d("Lifecycle", "ä¸´æ—¶åˆ›å»º500ä¸ªå¯¹è±¡ï¼Œå ç”¨å †å†…å­˜")
        
        // tempObjectså¼•ç”¨å­˜åœ¨æ ˆä¸­ï¼ŒUserå¯¹è±¡å­˜åœ¨å †ä¸­
        // æ–¹æ³•ç»“æŸæ—¶ï¼Œæ ˆä¸­çš„å¼•ç”¨æ¶ˆå¤±ï¼Œä½†å †ä¸­çš„å¯¹è±¡è¿˜å¯èƒ½å­˜åœ¨
    } // â† tempObjectså¼•ç”¨æ¶ˆå¤±ï¼Œä½†Userå¯¹è±¡ç­‰å¾…GCå›æ”¶
}

// ç®€å•çš„ç”¨æˆ·ç±»ï¼Œç”¨äºæ¼”ç¤ºå¯¹è±¡åˆ†é…
data class User(val name: String) {
    val id: Long = System.currentTimeMillis()
    val data: ByteArray = ByteArray(1024) { it.toByte() }  // 1KBæ•°æ®ï¼Œæ–¹ä¾¿è§‚å¯Ÿå†…å­˜å˜åŒ–
}
```

### 1.2 GCè¡Œä¸ºçš„å®æ—¶è§‚å¯Ÿ

```kotlin
/**
 * ç›®æ ‡ï¼šè§‚å¯ŸAndroid ARTçš„åƒåœ¾å›æ”¶è¡Œä¸º
 * éªŒè¯æ–¹æ³•ï¼šMemory Profiler + Logcat
 */
class Level1_GCObservation : AppCompatActivity() {
    
    private val objectHolder = mutableListOf<Any>()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        Log.d("GC", "=== GCè¡Œä¸ºè§‚å¯Ÿå®éªŒ ===")
        
        // å®éªŒ1ï¼šè§‚å¯Ÿæ­£å¸¸çš„GCè§¦å‘
        observeNormalGC()
        
        // å®éªŒ2ï¼šè§‚å¯Ÿå¤§å¯¹è±¡åˆ†é…æ—¶çš„GC
        observeLargeObjectGC()
        
        // å®éªŒ3ï¼šè§‚å¯Ÿå†…å­˜å‹åŠ›ä¸‹çš„GC
        observeMemoryPressureGC()
    }
    
    private fun observeNormalGC() {
        Log.d("GC", "--- æ­£å¸¸GCè§‚å¯Ÿ ---")
        
        repeat(10) { round ->
            // åˆ›å»ºä¸€æ‰¹å¯¹è±¡
            val batch = Array(100) { 
                User("Batch${round}_User$it").apply {
                    // æ·»åŠ ä¸€äº›æ•°æ®è®©å¯¹è±¡æ›´å¤§
                    largeData = ByteArray(10 * 1024) { it.toByte() }  // 10KB
                }
            }
            
            objectHolder.addAll(batch)
            
            // è®°å½•å†…å­˜çŠ¶æ€
            logMemoryState("Round $round")
            
            Thread.sleep(100)  // çŸ­æš‚ç­‰å¾…ï¼Œç»™GCæ—¶é—´è¿è¡Œ
        }
        
        // ğŸ’¡ åœ¨Memory Profilerä¸­è§‚å¯Ÿï¼š
        // 1. Java/Kotlinå†…å­˜å‘ˆé˜¶æ¢¯çŠ¶å¢é•¿
        // 2. å¯èƒ½çœ‹åˆ°é”¯é½¿çŠ¶çš„GCå›æ”¶æ¨¡å¼
        // 3. GCäº‹ä»¶åœ¨æ—¶é—´è½´ä¸Šçš„åˆ†å¸ƒ
    }
    
    private fun observeLargeObjectGC() {
        Log.d("GC", "--- å¤§å¯¹è±¡åˆ†é…GCè§‚å¯Ÿ ---")
        
        // åˆ†é…å¤§å¯¹è±¡é€šå¸¸ä¼šè§¦å‘GC
        repeat(5) { index ->
            Log.d("GC", "åˆ†é…å¤§å¯¹è±¡ $index")
            
            val beforeMemory = getCurrentMemoryUsage()
            
            // åˆ†é…5MBçš„å¤§å¯¹è±¡
            val largeObject = ByteArray(5 * 1024 * 1024) { it.toByte() }
            objectHolder.add(largeObject)
            
            val afterMemory = getCurrentMemoryUsage()
            
            Log.d("GC", "å¤§å¯¹è±¡åˆ†é…å‰åå†…å­˜: ${beforeMemory}KB -> ${afterMemory}KB")
            
            Thread.sleep(500)  // ç­‰å¾…è§‚å¯ŸGC
        }
        
        // ğŸ’¡ è§‚å¯Ÿè¦ç‚¹ï¼š
        // 1. å¤§å¯¹è±¡åˆ†é…å¯èƒ½ç«‹å³è§¦å‘GC
        // 2. åœ¨Memory Profilerä¸­çœ‹åˆ°çªç„¶çš„å†…å­˜å¢é•¿å’Œå¯èƒ½çš„GCäº‹ä»¶
    }
    
    private fun observeMemoryPressureGC() {
        Log.d("GC", "--- å†…å­˜å‹åŠ›GCè§‚å¯Ÿ ---")
        
        try {
            // æŒç»­åˆ†é…å†…å­˜ç›´åˆ°è§¦å‘é¢‘ç¹GC
            var counter = 0
            while (counter < 1000) {  // é™åˆ¶å¾ªç¯æ¬¡æ•°ï¼Œé¿å…OOM
                val objects = Array(50) { 
                    ByteArray(100 * 1024) { it.toByte() }  // æ¯ä¸ª100KB
                }
                objectHolder.addAll(objects)
                
                counter++
                
                if (counter % 10 == 0) {
                    logMemoryState("å‹åŠ›æµ‹è¯• Round $counter")
                    
                    // æ£€æŸ¥æ˜¯å¦æ¥è¿‘å†…å­˜é™åˆ¶
                    if (isNearingMemoryLimit()) {
                        Log.d("GC", "æ¥è¿‘å†…å­˜é™åˆ¶ï¼Œåœæ­¢åˆ†é…")
                        break
                    }
                }
                
                Thread.sleep(50)
            }
        } catch (e: OutOfMemoryError) {
            Log.e("GC", "å†…å­˜æº¢å‡º: ${e.message}")
        }
        
        // ğŸ’¡ è§‚å¯Ÿè¦ç‚¹ï¼š
        // 1. å†…å­˜å‹åŠ›å¢å¤§æ—¶ï¼ŒGCä¼šæ›´é¢‘ç¹è¿è¡Œ
        // 2. GCè€—æ—¶å¯èƒ½å¢åŠ ï¼ˆStop-The-Worldæ—¶é—´ï¼‰
        // 3. åº”ç”¨å¯èƒ½å‡ºç°å¡é¡¿
    }
    
    private fun logMemoryState(tag: String) {
        val runtime = Runtime.getRuntime()
        val totalMemory = runtime.totalMemory() / 1024
        val freeMemory = runtime.freeMemory() / 1024
        val usedMemory = totalMemory - freeMemory
        val maxMemory = runtime.maxMemory() / 1024
        
        Log.d("GC", "$tag - ä½¿ç”¨: ${usedMemory}KB, æ€»è®¡: ${totalMemory}KB, æœ€å¤§: ${maxMemory}KB")
    }
    
    private fun getCurrentMemoryUsage(): Long {
        val runtime = Runtime.getRuntime()
        return (runtime.totalMemory() - runtime.freeMemory()) / 1024
    }
    
    private fun isNearingMemoryLimit(): Boolean {
        val runtime = Runtime.getRuntime()
        val usedMemory = runtime.totalMemory() - runtime.freeMemory()
        val maxMemory = runtime.maxMemory()
        
        return (usedMemory.toDouble() / maxMemory) > 0.8  // ä½¿ç”¨è¶…è¿‡80%
    }
}

// æ‰©å±•Userç±»ä»¥æ”¯æŒå¤§æ•°æ®
data class User(val name: String) {
    val id: Long = System.currentTimeMillis()
    var largeData: ByteArray = ByteArray(0)
}
```

---

## ç¬¬2çº§ï¼šå†…å­˜åˆ†é…ä½ç½®éªŒè¯ï¼ˆè¿›é˜¶ç†è§£ï¼‰

### 2.1 ä¸‰å±‚å †ç»“æ„çš„å®é™…éªŒè¯

```kotlin
/**
 * ç›®æ ‡ï¼šéªŒè¯è¿›ç¨‹å †æ®µã€Nativeå †ã€ARTå †çš„ä¸‰å±‚ç»“æ„
 * éªŒè¯æ–¹æ³•ï¼šMemory Profiler + dumpsys meminfo
 */
class Level2_ThreeLayerHeap : AppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        Log.d("ThreeLayer", "=== ä¸‰å±‚å †ç»“æ„éªŒè¯ ===")
        
        // éªŒè¯1ï¼šART Javaå †åˆ†é…
        verifyARTHeapAllocation()
        
        // éªŒè¯2ï¼šNativeå †åˆ†é…
        verifyNativeHeapAllocation()
        
        // éªŒè¯3ï¼šå¯¹æ¯”Android 8å‰åçš„å›¾ç‰‡å†…å­˜åˆ†é…
        verifyBitmapMemoryLocation()
    }
    
    private fun verifyARTHeapAllocation() {
        Log.d("ThreeLayer", "--- ART Javaå †éªŒè¯ ---")
        
        val memInfo = Debug.MemoryInfo()
        
        // è®°å½•åˆ†é…å‰çŠ¶æ€
        Debug.getMemoryInfo(memInfo)
        val javaHeapBefore = memInfo.dalvikHeap
        val runtimeBefore = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()
        
        Log.d("ThreeLayer", "åˆ†é…å‰ - dalvikHeap: ${javaHeapBefore}KB, Runtime: ${runtimeBefore/1024}KB")
        
        // å¤§é‡åˆ†é…Javaå¯¹è±¡
        val javaObjects = Array(2000) { index ->
            User("JavaUser$index").apply {
                // æ¯ä¸ªå¯¹è±¡åŒ…å«ä¸€äº›æ•°æ®ï¼Œä¾¿äºè§‚å¯Ÿ
                extraData = "This is extra data for user $index".repeat(10)
            }
        }
        
        // è®°å½•åˆ†é…åçŠ¶æ€
        Thread.sleep(1000)  // ç­‰å¾…å†…å­˜ç»Ÿè®¡æ›´æ–°
        Debug.getMemoryInfo(memInfo)
        val javaHeapAfter = memInfo.dalvikHeap
        val runtimeAfter = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()
        
        Log.d("ThreeLayer", "åˆ†é…å - dalvikHeap: ${javaHeapAfter}KB, Runtime: ${runtimeAfter/1024}KB")
        Log.d("ThreeLayer", "Javaå †å¢é•¿: ${javaHeapAfter - javaHeapBefore}KB")
        
        // ğŸ’¡ éªŒè¯è¦ç‚¹ï¼š
        // 1. dalvikHeapï¼ˆARTå †ï¼‰æ˜¾è‘—å¢é•¿
        // 2. Runtimeç»Ÿè®¡ä¹Ÿç›¸åº”å¢é•¿
        // 3. åœ¨Memory Profilerä¸­Java/KotlinæŸ±çŠ¶å›¾å¢é•¿
        
        // ä¿æŒå¼•ç”¨ï¼Œé˜²æ­¢GCå›æ”¶å½±å“æµ‹è¯•
        Log.d("ThreeLayer", "åˆ›å»ºçš„Javaå¯¹è±¡æ•°é‡: ${javaObjects.size}")
    }
    
    private fun verifyNativeHeapAllocation() {
        Log.d("ThreeLayer", "--- Nativeå †éªŒè¯ ---")
        
        val memInfo = Debug.MemoryInfo()
        
        // è®°å½•åˆ†é…å‰çŠ¶æ€
        Debug.getMemoryInfo(memInfo)
        val nativeHeapBefore = memInfo.nativeHeap
        
        Log.d("ThreeLayer", "Nativeå †åˆ†é…å‰: ${nativeHeapBefore}KB")
        
        // é€šè¿‡Bitmapåˆ†é…Nativeå†…å­˜ï¼ˆAndroid 8+ï¼‰
        val bitmaps = mutableListOf<Bitmap>()
        repeat(10) { index ->
            // åˆ›å»ºå¤§å›¾ç‰‡ï¼Œåƒç´ æ•°æ®å­˜åœ¨Nativeå †ä¸­
            val bitmap = Bitmap.createBitmap(1024, 1024, Bitmap.Config.ARGB_8888)
            
            // å¡«å……ä¸€äº›æ•°æ®ï¼Œç¡®ä¿å†…å­˜çœŸæ­£åˆ†é…
            val canvas = Canvas(bitmap)
            canvas.drawColor(Color.rgb(index * 25, 128, 255 - index * 25))
            
            bitmaps.add(bitmap)
            
            Log.d("ThreeLayer", "åˆ›å»ºç¬¬${index + 1}ä¸ªBitmap (1024x1024)")
        }
        
        // è®°å½•åˆ†é…åçŠ¶æ€
        Thread.sleep(1000)
        Debug.getMemoryInfo(memInfo)
        val nativeHeapAfter = memInfo.nativeHeap
        
        Log.d("ThreeLayer", "Nativeå †åˆ†é…å: ${nativeHeapAfter}KB")
        Log.d("ThreeLayer", "Nativeå †å¢é•¿: ${nativeHeapAfter - nativeHeapBefore}KB")
        
        // ğŸ’¡ éªŒè¯è¦ç‚¹ï¼š
        // 1. nativeHeapæ˜¾è‘—å¢é•¿ï¼ˆçº¦40MBï¼Œ10ä¸ª4MBçš„ARGBå›¾ç‰‡ï¼‰
        // 2. åœ¨Memory Profilerä¸­NativeæŸ±çŠ¶å›¾å¢é•¿
        // 3. Java/Kotlinå †ä»…æœ‰å°‘é‡å¢é•¿ï¼ˆBitmapå¯¹è±¡æœ¬èº«ï¼‰
        
        // è®¡ç®—ç†è®ºåƒç´ æ•°æ®å¤§å°
        val expectedPixelData = 10 * 1024 * 1024 * 4 / 1024  // 10å¼ å›¾ç‰‡ï¼Œæ¯å¼ 4MB
        Log.d("ThreeLayer", "é¢„æœŸåƒç´ æ•°æ®å¤§å°: ${expectedPixelData}KB")
        
        // ä¿æŒBitmapå¼•ç”¨ï¼Œé˜²æ­¢Nativeå†…å­˜è¢«å›æ”¶
        Log.d("ThreeLayer", "åˆ›å»ºçš„Bitmapæ•°é‡: ${bitmaps.size}")
    }
    
    private fun verifyBitmapMemoryLocation() {
        Log.d("ThreeLayer", "--- å›¾ç‰‡å†…å­˜ä½ç½®éªŒè¯ ---")
        
        val memInfo = Debug.MemoryInfo()
        
        // è®°å½•åŸºå‡†çŠ¶æ€
        Debug.getMemoryInfo(memInfo)
        val baselineJava = memInfo.dalvikHeap
        val baselineNative = memInfo.nativeHeap
        
        Log.d("ThreeLayer", "åŸºå‡† - Java: ${baselineJava}KB, Native: ${baselineNative}KB")
        
        // åŠ è½½ä¸€å¼ å¤§å›¾ç‰‡
        val largeBitmap = BitmapFactory.decodeResource(resources, R.drawable.large_sample)
        
        Thread.sleep(1000)
        Debug.getMemoryInfo(memInfo)
        val afterJava = memInfo.dalvikHeap
        val afterNative = memInfo.nativeHeap
        
        val javaGrowth = afterJava - baselineJava
        val nativeGrowth = afterNative - baselineNative
        
        Log.d("ThreeLayer", "åŠ è½½å¤§å›¾å - Javaå¢é•¿: ${javaGrowth}KB, Nativeå¢é•¿: ${nativeGrowth}KB")
        
        // åˆ†æç»“æœ
        if (nativeGrowth > javaGrowth * 5) {  // Nativeå¢é•¿è¿œå¤§äºJavaå¢é•¿
            Log.d("ThreeLayer", "âœ“ éªŒè¯æˆåŠŸï¼šå›¾ç‰‡åƒç´ æ•°æ®å­˜å‚¨åœ¨Nativeå †ä¸­ï¼ˆAndroid 8+ç‰¹æ€§ï¼‰")
        } else if (javaGrowth > nativeGrowth * 5) {
            Log.d("ThreeLayer", "â“˜ æ£€æµ‹åˆ°ï¼šå›¾ç‰‡åƒç´ æ•°æ®å­˜å‚¨åœ¨Javaå †ä¸­ï¼ˆAndroid 7åŠä¹‹å‰ç‰¹æ€§ï¼‰")
        } else {
            Log.d("ThreeLayer", "? å†…å­˜åˆ†é…æ¨¡å¼ä¸æ˜ç¡®ï¼Œå¯èƒ½éœ€è¦æ›´å¤§çš„å›¾ç‰‡è¿›è¡Œæµ‹è¯•")
        }
        
        // ğŸ’¡ éªŒè¯è¦ç‚¹ï¼š
        // Android 8+: nativeHeapæ˜¾è‘—å¢é•¿ï¼ŒdalvikHeapå°å¹…å¢é•¿
        // Android 7-: dalvikHeapæ˜¾è‘—å¢é•¿ï¼ŒnativeHeapå°å¹…å¢é•¿
        
        // æ‰“å°å›¾ç‰‡ä¿¡æ¯
        largeBitmap?.let { bitmap ->
            val pixelBytes = bitmap.width * bitmap.height * 4  // ARGBæ¯åƒç´ 4å­—èŠ‚
            Log.d("ThreeLayer", "å›¾ç‰‡ä¿¡æ¯: ${bitmap.width}x${bitmap.height}, åƒç´ æ•°æ®çº¦${pixelBytes/1024}KB")
        }
    }
}

// æ‰©å±•Userç±»
data class User(val name: String) {
    val id: Long = System.currentTimeMillis()
    var extraData: String = ""
}
```

### 2.2 å†…å­˜æ˜ å°„å’Œè™šæ‹Ÿåœ°å€ç©ºé—´æ¢ç´¢

```kotlin
/**
 * ç›®æ ‡ï¼šç†è§£è¿›ç¨‹è™šæ‹Ÿåœ°å€ç©ºé—´å’Œå†…å­˜æ˜ å°„
 * éªŒè¯æ–¹æ³•ï¼š/proc/[pid]/maps + è‡ªå®šä¹‰åˆ†æ
 */
class Level2_VirtualMemoryExplorer : AppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        Log.d("VirtualMemory", "=== è™šæ‹Ÿå†…å­˜ç©ºé—´æ¢ç´¢ ===")
        
        // æ¢ç´¢1ï¼šåˆ†æå½“å‰è¿›ç¨‹çš„å†…å­˜æ˜ å°„
        analyzeProcessMemoryMaps()
        
        // æ¢ç´¢2ï¼šè§‚å¯Ÿå†…å­˜åˆ†é…å¯¹åœ°å€ç©ºé—´çš„å½±å“
        observeMemoryAllocationEffect()
        
        // æ¢ç´¢3ï¼šç†è§£å…±äº«åº“çš„å†…å­˜æ˜ å°„
        analyzeSharedLibraryMapping()
    }
    
    private fun analyzeProcessMemoryMaps() {
        Log.d("VirtualMemory", "--- è¿›ç¨‹å†…å­˜æ˜ å°„åˆ†æ ---")
        
        val processId = android.os.Process.myPid()
        Log.d("VirtualMemory", "å½“å‰è¿›ç¨‹ID: $processId")
        
        // ğŸ’¡ æ‰‹åŠ¨æ‰§è¡Œä»¥ä¸‹å‘½ä»¤æ¥æŸ¥çœ‹å†…å­˜æ˜ å°„ï¼š
        // adb shell cat /proc/$processId/maps
        
        Log.d("VirtualMemory", """
            |ğŸ’¡ è¯·æ‰‹åŠ¨æ‰§è¡Œä»¥ä¸‹å‘½ä»¤æŸ¥çœ‹å†…å­˜æ˜ å°„ï¼š
            |adb shell cat /proc/$processId/maps
            |
            |å…³é”®æ˜ å°„åŒºåŸŸè¯´æ˜ï¼š
            |[heap] - è¿›ç¨‹ä¸»å †æ®µ
            |[anon:libc_malloc] - Nativeå †çš„åŒ¿åå†…å­˜åŒºåŸŸ
            |[anon:dalvik-main space] - ARTè™šæ‹Ÿæœºä¸»å †ç©ºé—´
            |[stack] - ä¸»çº¿ç¨‹æ ˆ
            |libxxx.so - å„ç§åŠ¨æ€é“¾æ¥åº“
        """.trimMargin())
        
        // åˆ›å»ºä¸€äº›å¯¹è±¡ï¼Œç„¶åå†æ¬¡æŸ¥çœ‹æ˜ å°„å˜åŒ–
        createObjectsForMappingObservation()
        
        Log.d("VirtualMemory", """
            |ğŸ’¡ ç°åœ¨å†æ¬¡æ‰§è¡Œå‘½ä»¤ï¼Œè§‚å¯Ÿå†…å­˜æ˜ å°„çš„å˜åŒ–ï¼š
            |adb shell cat /proc/$processId/maps | grep -E "(heap|dalvik|malloc)"
        """.trimMargin())
    }
    
    private fun createObjectsForMappingObservation() {
        Log.d("VirtualMemory", "åˆ›å»ºå¯¹è±¡ä»¥è§‚å¯Ÿå†…å­˜æ˜ å°„å˜åŒ–...")
        
        // åˆ›å»ºå¤§é‡Javaå¯¹è±¡
        val javaObjects = Array(1000) { User("MapUser$it") }
        
        // åˆ›å»ºBitmapä»¥åˆ†é…Nativeå†…å­˜
        val bitmap = Bitmap.createBitmap(2048, 2048, Bitmap.Config.ARGB_8888)
        
        // åˆ†é…å¤§é‡Nativeå†…å­˜ï¼ˆå¦‚æœæœ‰JNIä»£ç ï¼‰
        // val nativeBuffer = allocateNativeMemory(10 * 1024 * 1024)  // 10MB
        
        Log.d("VirtualMemory", "å¯¹è±¡åˆ›å»ºå®Œæˆï¼ŒJavaå¯¹è±¡: ${javaObjects.size}, Bitmap: ${bitmap.width}x${bitmap.height}")
    }
    
    private fun observeMemoryAllocationEffect() {
        Log.d("VirtualMemory", "--- è§‚å¯Ÿå†…å­˜åˆ†é…å¯¹åœ°å€ç©ºé—´çš„å½±å“ ---")
        
        // è®°å½•åˆ†é…å‰çš„çŠ¶æ€
        logVirtualMemoryUsage("åˆ†é…å‰")
        
        // é˜¶æ®µ1ï¼šåˆ†é…Javaå¯¹è±¡
        val phase1Objects = Array(500) { User("Phase1_$it") }
        logVirtualMemoryUsage("Javaå¯¹è±¡åˆ†é…å")
        
        // é˜¶æ®µ2ï¼šåˆ†é…Bitmap
        val phase2Bitmaps = Array(5) { 
            Bitmap.createBitmap(1024, 1024, Bitmap.Config.ARGB_8888)
        }
        logVirtualMemoryUsage("Bitmapåˆ†é…å")
        
        // é˜¶æ®µ3ï¼šåˆ†é…å¤§æ•°ç»„
        val phase3Arrays = Array(10) { ByteArray(1024 * 1024) }  // æ¯ä¸ª1MB
        logVirtualMemoryUsage("å¤§æ•°ç»„åˆ†é…å")
        
        // ğŸ’¡ è§‚å¯Ÿè¦ç‚¹ï¼š
        // 1. è™šæ‹Ÿå†…å­˜å¤§å°çš„å˜åŒ–
        // 2. ç‰©ç†å†…å­˜ä½¿ç”¨çš„å˜åŒ–
        // 3. ä¸åŒç±»å‹åˆ†é…å¯¹å†…å­˜ç»Ÿè®¡çš„å½±å“
        
        // ä¿æŒå¼•ç”¨ï¼Œé˜²æ­¢GCå½±å“è§‚å¯Ÿ
        Log.d("VirtualMemory", "ä¿æŒå¼•ç”¨ - Java: ${phase1Objects.size}, Bitmap: ${phase2Bitmaps.size}, Array: ${phase3Arrays.size}")
    }
    
    private fun logVirtualMemoryUsage(phase: String) {
        try {
            val processId = android.os.Process.myPid()
            val statusFile = File("/proc/$processId/status")
            
            if (statusFile.exists() && statusFile.canRead()) {
                val lines = statusFile.readLines()
                val vmSize = lines.find { it.startsWith("VmSize:") }?.substringAfter("VmSize:")?.trim()
                val vmRSS = lines.find { it.startsWith("VmRSS:") }?.substringAfter("VmRSS:")?.trim()
                val vmPeak = lines.find { it.startsWith("VmPeak:") }?.substringAfter("VmPeak:")?.trim()
                
                Log.d("VirtualMemory", """
                    |$phase:
                    |  è™šæ‹Ÿå†…å­˜å¤§å°: $vmSize
                    |  ç‰©ç†å†…å­˜ä½¿ç”¨: $vmRSS  
                    |  è™šæ‹Ÿå†…å­˜å³°å€¼: $vmPeak
                """.trimMargin())
            } else {
                Log.w("VirtualMemory", "æ— æ³•è¯»å– /proc/$processId/status")
            }
        } catch (e: Exception) {
            Log.e("VirtualMemory", "è¯»å–è™šæ‹Ÿå†…å­˜ä¿¡æ¯å¤±è´¥: ${e.message}")
        }
        
        // å¤‡ç”¨æ–¹æ³•ï¼šä½¿ç”¨ActivityManagerè·å–å†…å­˜ä¿¡æ¯
        val activityManager = getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
        val memInfo = ActivityManager.MemoryInfo()
        activityManager.getMemoryInfo(memInfo)
        
        Log.d("VirtualMemory", """
            |$phase (ç³»ç»Ÿå†…å­˜):
            |  å¯ç”¨å†…å­˜: ${memInfo.availMem / 1024 / 1024}MB
            |  æ€»å†…å­˜: ${memInfo.totalMem / 1024 / 1024}MB
            |  å†…å­˜ä¸è¶³: ${memInfo.lowMemory}
        """.trimMargin())
    }
    
    private fun analyzeSharedLibraryMapping() {
        Log.d("VirtualMemory", "--- å…±äº«åº“å†…å­˜æ˜ å°„åˆ†æ ---")
        
        val processId = android.os.Process.myPid()
        
        Log.d("VirtualMemory", """
            |ğŸ’¡ æ‰§è¡Œä»¥ä¸‹å‘½ä»¤åˆ†æå…±äº«åº“æ˜ å°„ï¼š
            |adb shell cat /proc/$processId/maps | grep "\.so"
            |
            |è§‚å¯Ÿè¦ç‚¹ï¼š
            |1. libart.so - ARTè™šæ‹Ÿæœºåº“
            |2. libc.so - Cæ ‡å‡†åº“
            |3. libdl.so - åŠ¨æ€åŠ è½½åº“
            |4. åº”ç”¨ç›¸å…³çš„.soæ–‡ä»¶
            |
            |å…±äº«åº“çš„ç‰¹ç‚¹ï¼š
            |- å¤šä¸ªè¿›ç¨‹å¯ä»¥å…±äº«åŒä¸€ä»½åº“çš„ä»£ç æ®µ
            |- æ•°æ®æ®µæ˜¯è¿›ç¨‹ç§æœ‰çš„
            |- é€šè¿‡Copy-On-Writeæœºåˆ¶ä¼˜åŒ–å†…å­˜ä½¿ç”¨
        """.trimMargin())
        
        // å¦‚æœåº”ç”¨æœ‰JNIåº“ï¼Œå¯ä»¥è§¦å‘åŠ è½½
        try {
            // System.loadLibrary("your_native_lib")
            Log.d("VirtualMemory", "å¦‚æœæœ‰JNIåº“ï¼Œæ­¤å¤„ä¼šè§¦å‘åº“åŠ è½½å’Œå†…å­˜æ˜ å°„")
        } catch (e: Exception) {
            Log.d("VirtualMemory", "æ²¡æœ‰JNIåº“éœ€è¦åŠ è½½")
        }
    }
}
```

---

## ç¬¬3çº§ï¼šå†…å­˜é—®é¢˜è¯Šæ–­ä¸ä¼˜åŒ–ï¼ˆé«˜çº§åº”ç”¨ï¼‰

### 3.1 å†…å­˜æ³„æ¼çš„åˆ›å»ºã€æ£€æµ‹å’Œä¿®å¤

```kotlin
/**
 * ç›®æ ‡ï¼šåˆ›å»ºçœŸå®çš„å†…å­˜æ³„æ¼åœºæ™¯ï¼Œå­¦ä¹ æ£€æµ‹å’Œä¿®å¤æ–¹æ³•
 * éªŒè¯æ–¹æ³•ï¼šLeakCanary + Memory Profiler + MAT
 */
class Level3_MemoryLeakDemo : AppCompatActivity() {
    
    companion object {
        // é™æ€å¼•ç”¨ï¼Œå¯èƒ½å¯¼è‡´å†…å­˜æ³„æ¼
        private val staticActivityRefs = mutableListOf<Activity>()
        private var staticHandler: Handler? = null
    }
    
    // åŒ¿åå†…éƒ¨ç±»ï¼ŒæŒæœ‰å¤–éƒ¨ç±»å¼•ç”¨
    private val problemHandler = Handler(Looper.getMainLooper())
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        Log.d("MemoryLeak", "=== å†…å­˜æ³„æ¼æ¼”ç¤ºä¸ä¿®å¤ ===")
        
        // æ³„æ¼åœºæ™¯1ï¼šé™æ€å¼•ç”¨æŒæœ‰Activity
        demonstrateStaticReferenceLeak()
        
        // æ³„æ¼åœºæ™¯2ï¼šHandlerå»¶è¿Ÿæ¶ˆæ¯
        demonstrateHandlerLeak()
        
        // æ³„æ¼åœºæ™¯3ï¼šç›‘å¬å™¨æœªæ³¨é”€
        demonstrateListenerLeak()
        
        // æ³„æ¼åœºæ™¯4ï¼šéé™æ€å†…éƒ¨ç±»
        demonstrateInnerClassLeak()
        
        // ä¿®å¤æ¼”ç¤º
        demonstrateLeakFixes()
    }
    
    private fun demonstrateStaticReferenceLeak() {
        Log.d("MemoryLeak", "--- åœºæ™¯1ï¼šé™æ€å¼•ç”¨æ³„æ¼ ---")
        
        // âŒ é”™è¯¯åšæ³•ï¼šé™æ€å¼•ç”¨æŒæœ‰Activity
        staticActivityRefs.add(this)  // è¿™ä¼šå¯¼è‡´Activityæ— æ³•è¢«GCå›æ”¶
        
        Log.d("MemoryLeak", "å·²æ·»åŠ Activityåˆ°é™æ€åˆ—è¡¨ï¼Œå½“å‰æ•°é‡: ${staticActivityRefs.size}")
        
        // ğŸ’¡ æ£€æµ‹æ–¹æ³•ï¼š
        // 1. ä½¿ç”¨LeakCanaryè‡ªåŠ¨æ£€æµ‹
        // 2. åœ¨Memory Profilerä¸­æ•è·heap dumpï¼ŒæŸ¥çœ‹Activityå®ä¾‹æ•°é‡
        // 3. å¤šæ¬¡æ—‹è½¬å±å¹•æˆ–é‡å¯Activityï¼Œè§‚å¯ŸActivityå®ä¾‹æ˜¯å¦å¢é•¿
        
        // æ¨¡æ‹Ÿä¿®å¤ï¼šåœ¨åˆé€‚çš„æ—¶æœºæ¸…ç†å¼•ç”¨
        // staticActivityRefs.removeAll { it is Level3_MemoryLeakDemo }
    }
    
    private fun demonstrateHandlerLeak() {
        Log.d("MemoryLeak", "--- åœºæ™¯2ï¼šHandleræ¶ˆæ¯æ³„æ¼ ---")
        
        // âŒ é”™è¯¯åšæ³•ï¼šåŒ¿åå†…éƒ¨ç±»Handler + é•¿å»¶è¿Ÿæ¶ˆæ¯
        problemHandler.postDelayed({
            // è¿™ä¸ªRunnableæ˜¯åŒ¿åå†…éƒ¨ç±»ï¼ŒæŒæœ‰Activityçš„éšå¼å¼•ç”¨
            // å³ä½¿Activityè¢«é”€æ¯ï¼Œè¿™ä¸ªå»¶è¿Ÿæ¶ˆæ¯ä»ç„¶æŒæœ‰Activityå¼•ç”¨
            Log.d("MemoryLeak", "å»¶è¿Ÿæ¶ˆæ¯æ‰§è¡Œï¼Œä½†Activityå¯èƒ½å·²è¢«é”€æ¯")
            updateUI()  // éšå¼çš„this.updateUI()
        }, 30000)  // 30ç§’å»¶è¿Ÿï¼Œè¶³å¤ŸActivityè¢«é”€æ¯å¤šæ¬¡
        
        // âŒ æ›´ä¸¥é‡çš„åšæ³•ï¼šé™æ€Handler
        if (staticHandler == null) {
            staticHandler = Handler(Looper.getMainLooper())
        }
        
        staticHandler?.postDelayed({
            // é™æ€Handler + åŒ¿åRunnableï¼ŒåŒé‡æ³„æ¼
            Log.d("MemoryLeak", "é™æ€Handleræ‰§è¡Œå»¶è¿Ÿä»»åŠ¡")
        }, 60000)  // 60ç§’å»¶è¿Ÿ
        
        Log.d("MemoryLeak", "å·²å‘é€é•¿å»¶è¿Ÿæ¶ˆæ¯ï¼Œå¯èƒ½å¯¼è‡´Activityæ³„æ¼")
        
        // ğŸ’¡ æ£€æµ‹æ–¹æ³•ï¼š
        // 1. LeakCanaryä¼šæ£€æµ‹åˆ°Handleræ¶ˆæ¯é˜Ÿåˆ—æŒæœ‰Activity
        // 2. åœ¨Memory Profilerä¸­æŸ¥çœ‹MessageQueueçš„å¼•ç”¨é“¾
    }
    
    private fun demonstrateListenerLeak() {
        Log.d("MemoryLeak", "--- åœºæ™¯3ï¼šç›‘å¬å™¨æœªæ³¨é”€æ³„æ¼ ---")
        
        // âŒ é”™è¯¯åšæ³•ï¼šæ³¨å†Œç›‘å¬å™¨ä½†ä¸æ³¨é”€
        val sharedPrefs = getSharedPreferences("demo", Context.MODE_PRIVATE)
        val listener = SharedPreferences.OnSharedPreferenceChangeListener { prefs, key ->
            // è¿™ä¸ªç›‘å¬å™¨æŒæœ‰Activityå¼•ç”¨
            Log.d("MemoryLeak", "SharedPreferences changed: $key")
            // å¯èƒ½è®¿é—®Activityçš„æ–¹æ³•æˆ–å­—æ®µ
            updateUI()
        }
        
        sharedPrefs.registerOnSharedPreferenceChangeListener(listener)
        
        // âŒ å¿˜è®°åœ¨onDestroyä¸­æ³¨é”€ç›‘å¬å™¨
        // sharedPrefs.unregisterOnSharedPreferenceChangeListener(listener)
        
        // æ¨¡æ‹Ÿå…¶ä»–ç±»å‹çš„ç›‘å¬å™¨æ³„æ¼
        registerBroadcastReceiver()  // BroadcastReceiveræ³„æ¼
        registerEventBusListener()  // EventBusæ³„æ¼
        
        Log.d("MemoryLeak", "å·²æ³¨å†Œå¤šä¸ªç›‘å¬å™¨ï¼Œä½†æœªæ­£ç¡®æ³¨é”€")
        
        // ğŸ’¡ æ£€æµ‹æ–¹æ³•ï¼š
        // 1. LeakCanaryèƒ½æ£€æµ‹å¤§éƒ¨åˆ†ç›‘å¬å™¨æ³„æ¼
        // 2. æ‰‹åŠ¨åˆ†æheap dumpä¸­çš„ç›‘å¬å™¨å¼•ç”¨é“¾
    }
    
    private fun demonstrateInnerClassLeak() {
        Log.d("MemoryLeak", "--- åœºæ™¯4ï¼šéé™æ€å†…éƒ¨ç±»æ³„æ¼ ---")
        
        // âŒ é”™è¯¯åšæ³•ï¼šéé™æ€å†…éƒ¨ç±» + å¼‚æ­¥ä»»åŠ¡
        val asyncTask = object : Thread() {
            override fun run() {
                try {
                    // æ¨¡æ‹Ÿé•¿æ—¶é—´è¿è¡Œçš„ä»»åŠ¡
                    Thread.sleep(45000)  // 45ç§’
                    
                    // éé™æ€å†…éƒ¨ç±»éšå¼æŒæœ‰å¤–éƒ¨ç±»å¼•ç”¨
                    // å³ä½¿Activityè¢«é”€æ¯ï¼Œè¿™ä¸ªçº¿ç¨‹ä»ç„¶æŒæœ‰Activityå¼•ç”¨
                    Log.d("MemoryLeak", "å¼‚æ­¥ä»»åŠ¡å®Œæˆ")
                    
                    // å°è¯•è®¿é—®å¤–éƒ¨Activityçš„æ–¹æ³•ï¼ˆå±é™©ï¼ï¼‰
                    post {
                        updateUI()  // å¯èƒ½åœ¨Activityé”€æ¯åè°ƒç”¨
                    }
                } catch (e: InterruptedException) {
                    Log.d("MemoryLeak", "å¼‚æ­¥ä»»åŠ¡è¢«ä¸­æ–­")
                }
            }
        }
        
        asyncTask.start()
        
        // âŒ å¿˜è®°åœ¨onDestroyä¸­å–æ¶ˆä»»åŠ¡
        // asyncTask.interrupt()
        
        Log.d("MemoryLeak", "å·²å¯åŠ¨é•¿æ—¶é—´è¿è¡Œçš„å¼‚æ­¥ä»»åŠ¡")
    }
    
    private fun demonstrateLeakFixes() {
        Log.d("MemoryLeak", "--- å†…å­˜æ³„æ¼ä¿®å¤æ¼”ç¤º ---")
        
        // âœ… ä¿®å¤1ï¼šä½¿ç”¨WeakReference
        fixStaticReferenceWithWeakRef()
        
        // âœ… ä¿®å¤2ï¼šé™æ€å†…éƒ¨ç±» + WeakReference
        fixHandlerWithStaticInnerClass()
        
        // âœ… ä¿®å¤3ï¼šç”Ÿå‘½å‘¨æœŸç®¡ç†
        demonstrateLifecycleManagement()
    }
    
    private fun fixStaticReferenceWithWeakRef() {
        Log.d("MemoryLeak", "âœ… ä¿®å¤ï¼šä½¿ç”¨WeakReferenceæ›¿ä»£å¼ºå¼•ç”¨")
        
        // âœ… æ­£ç¡®åšæ³•ï¼šä½¿ç”¨WeakReferenceåŒ…è£…Activityå¼•ç”¨
        val weakActivityRef = WeakReference(this)
        
        // å¦‚æœéœ€è¦é™æ€æŒæœ‰ï¼Œä½¿ç”¨WeakReference
        StaticActivityHolder.addActivity(this)
        
        // ä½¿ç”¨æ—¶æ£€æŸ¥å¼•ç”¨æ˜¯å¦è¿˜æœ‰æ•ˆ
        weakActivityRef.get()?.let { activity ->
            Log.d("MemoryLeak", "Activityä»ç„¶æœ‰æ•ˆï¼Œå¯ä»¥å®‰å…¨ä½¿ç”¨")
        } ?: Log.d("MemoryLeak", "Activityå·²è¢«å›æ”¶")
    }
    
    private fun fixHandlerWithStaticInnerClass() {
        Log.d("MemoryLeak", "âœ… ä¿®å¤ï¼šé™æ€å†…éƒ¨ç±»Handler + WeakReference")
        
        // âœ… æ­£ç¡®åšæ³•ï¼šä½¿ç”¨é™æ€å†…éƒ¨ç±»
        val safeHandler = SafeHandler(this)
        safeHandler.sendMessageDelayed(Message.obtain(safeHandler, MSG_UPDATE_UI), 30000)
        
        Log.d("MemoryLeak", "ä½¿ç”¨å®‰å…¨çš„Handlerå‘é€å»¶è¿Ÿæ¶ˆæ¯")
    }
    
    private fun demonstrateLifecycleManagement() {
        Log.d("MemoryLeak", "âœ… ä¿®å¤ï¼šæ­£ç¡®çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†")
        
        // âœ… æ­£ç¡®åšæ³•ï¼šä¸ç”Ÿå‘½å‘¨æœŸç»‘å®šçš„èµ„æºç®¡ç†
        lifecycle.addObserver(object : DefaultLifecycleObserver {
            override fun onDestroy(owner: LifecycleOwner) {
                Log.d("MemoryLeak", "Activityé”€æ¯ï¼Œæ¸…ç†æ‰€æœ‰èµ„æº")
                
                // æ¸…ç†Handleræ¶ˆæ¯
                problemHandler.removeCallbacksAndMessages(null)
                staticHandler?.removeCallbacksAndMessages(null)
                
                // æ¸…ç†ç›‘å¬å™¨
                cleanupListeners()
                
                // æ¸…ç†é™æ€å¼•ç”¨
                staticActivityRefs.clear()
                
                super.onDestroy(owner)
            }
        })
    }
    
    private fun updateUI() {
        // æ¨¡æ‹ŸUIæ›´æ–°æ“ä½œ
        Log.d("MemoryLeak", "UIæ›´æ–°æ“ä½œ")
    }
    
    private fun registerBroadcastReceiver() {
        // æ¨¡æ‹Ÿæ³¨å†ŒBroadcastReceiver
        Log.d("MemoryLeak", "æ³¨å†ŒBroadcastReceiverï¼ˆæ¼”ç¤ºç”¨ï¼‰")
    }
    
    private fun registerEventBusListener() {
        // æ¨¡æ‹Ÿæ³¨å†ŒEventBusç›‘å¬å™¨
        Log.d("MemoryLeak", "æ³¨å†ŒEventBusç›‘å¬å™¨ï¼ˆæ¼”ç¤ºç”¨ï¼‰")
    }
    
    private fun cleanupListeners() {
        Log.d("MemoryLeak", "æ¸…ç†æ‰€æœ‰ç›‘å¬å™¨")
        // å®é™…é¡¹ç›®ä¸­åœ¨è¿™é‡Œæ¸…ç†æ‰€æœ‰æ³¨å†Œçš„ç›‘å¬å™¨
    }
    
    // âœ… æ­£ç¡®çš„Handlerå®ç°
    class SafeHandler(activity: Level3_MemoryLeakDemo) : Handler(Looper.getMainLooper()) {
        private val activityRef = WeakReference(activity)
        
        override fun handleMessage(msg: Message) {
            val activity = activityRef.get()
            if (activity != null && !activity.isFinishing && !activity.isDestroyed) {
                when (msg.what) {
                    MSG_UPDATE_UI -> {
                        activity.updateUI()
                        Log.d("MemoryLeak", "å®‰å…¨Handleræ‰§è¡ŒUIæ›´æ–°")
                    }
                }
            } else {
                Log.d("MemoryLeak", "Activityå·²é”€æ¯ï¼Œå–æ¶ˆHandleræ¶ˆæ¯æ‰§è¡Œ")
            }
        }
    }
    
    companion object {
        private const val MSG_UPDATE_UI = 1001
    }
}

// âœ… å®‰å…¨çš„é™æ€ActivityæŒæœ‰è€…
object StaticActivityHolder {
    private val activityRefs = mutableListOf<WeakReference<Activity>>()
    
    fun addActivity(activity: Activity) {
        // æ¸…ç†å·²å›æ”¶çš„å¼•ç”¨
        activityRefs.removeAll { it.get() == null }
        
        // æ·»åŠ æ–°çš„å¼±å¼•ç”¨
        activityRefs.add(WeakReference(activity))
        
        Log.d("StaticHolder", "å½“å‰æŒæœ‰Activityæ•°é‡: ${activityRefs.size}")
    }
    
    fun getActiveActivities(): List<Activity> {
        return activityRefs.mapNotNull { it.get() }
    }
}
```

### 3.2 æ€§èƒ½ä¼˜åŒ–ç»¼åˆå®è·µ

```kotlin
/**
 * ç›®æ ‡ï¼šç»¼åˆåº”ç”¨å†…å­˜ç®¡ç†çŸ¥è¯†è¿›è¡Œæ€§èƒ½ä¼˜åŒ–
 * éªŒè¯æ–¹æ³•ï¼šæ€§èƒ½å¯¹æ¯”æµ‹è¯• + Memory Profiler
 */
class Level3_PerformanceOptimization : AppCompatActivity() {
    
    // å¯¹è±¡æ± 
    private val bitmapPool = BitmapPool()
    private val stringBuilderPool = ObjectPool<StringBuilder> { StringBuilder() }
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        Log.d("Optimization", "=== å†…å­˜æ€§èƒ½ä¼˜åŒ–ç»¼åˆå®è·µ ===")
        
        // ä¼˜åŒ–1ï¼šå¯¹è±¡å¤ç”¨ vs é¢‘ç¹åˆ›å»º
        compareObjectReuse()
        
        // ä¼˜åŒ–2ï¼šå†…å­˜ç¼“å­˜ä¼˜åŒ–
        demonstrateMemoryCache()
        
        // ä¼˜åŒ–3ï¼šå›¾ç‰‡å†…å­˜ä¼˜åŒ–
        demonstrateBitmapOptimization()
        
        // ä¼˜åŒ–4ï¼šå­—ç¬¦ä¸²æ“ä½œä¼˜åŒ–
        demonstrateStringOptimization()
    }
    
    private fun compareObjectReuse() {
        Log.d("Optimization", "--- å¯¹è±¡å¤ç”¨ vs é¢‘ç¹åˆ›å»ºå¯¹æ¯” ---")
        
        val iterations = 1000
        
        // æµ‹è¯•1ï¼šé¢‘ç¹åˆ›å»ºå¯¹è±¡ï¼ˆä¸æ¨èï¼‰
        val startTime1 = System.currentTimeMillis()
        val startMemory1 = getCurrentMemoryUsage()
        
        repeat(iterations) {
            // æ¯æ¬¡éƒ½åˆ›å»ºæ–°çš„StringBuilder
            val sb = StringBuilder()
            sb.append("Item $it")
            val result = sb.toString()
            // sbå¯¹è±¡å˜ä¸ºåƒåœ¾ï¼Œç­‰å¾…GCå›æ”¶
        }
        
        val endTime1 = System.currentTimeMillis()
        val endMemory1 = getCurrentMemoryUsage()
        
        Log.d("Optimization", """
            |é¢‘ç¹åˆ›å»ºæ¨¡å¼:
            |  è€—æ—¶: ${endTime1 - startTime1}ms
            |  å†…å­˜å¢é•¿: ${endMemory1 - startMemory1}KB
        """.trimMargin())
        
        // æ‰‹åŠ¨è§¦å‘GCï¼Œæ¸…ç†åƒåœ¾å¯¹è±¡
        System.gc()
        Thread.sleep(1000)
        
        // æµ‹è¯•2ï¼šå¯¹è±¡å¤ç”¨æ¨¡å¼ï¼ˆæ¨èï¼‰
        val startTime2 = System.currentTimeMillis()
        val startMemory2 = getCurrentMemoryUsage()
        
        repeat(iterations) {
            // ä»å¯¹è±¡æ± è·å–StringBuilder
            val sb = stringBuilderPool.acquire()
            sb.clear()  // æ¸…ç©ºä¹‹å‰çš„å†…å®¹
            sb.append("Item $it")
            val result = sb.toString()
            stringBuilderPool.release(sb)  // å½’è¿˜ç»™å¯¹è±¡æ± 
        }
        
        val endTime2 = System.currentTimeMillis()
        val endMemory2 = getCurrentMemoryUsage()
        
        Log.d("Optimization", """
            |å¯¹è±¡å¤ç”¨æ¨¡å¼:
            |  è€—æ—¶: ${endTime2 - startTime2}ms  
            |  å†…å­˜å¢é•¿: ${endMemory2 - startMemory2}KB
            |
            |æ€§èƒ½æ”¹å–„:
            |  é€Ÿåº¦æå‡: ${((endTime1 - startTime1) - (endTime2 - startTime2))}ms
            |  å†…å­˜èŠ‚çº¦: ${(endMemory1 - startMemory1) - (endMemory2 - startMemory2)}KB
        """.trimMargin())
        
        // ğŸ’¡ åœ¨Memory Profilerä¸­è§‚å¯Ÿï¼š
        // 1. å¯¹è±¡å¤ç”¨æ¨¡å¼çš„GCäº‹ä»¶æ›´å°‘
        // 2. å†…å­˜åˆ†é…é€Ÿç‡æ›´ä½
        // 3. å†…å­˜ä½¿ç”¨æ›´å¹³ç¨³
    }
    
    private fun demonstrateMemoryCache() {
        Log.d("Optimization", "--- å†…å­˜ç¼“å­˜ä¼˜åŒ– ---")
        
        // åˆ›å»ºLRUç¼“å­˜
        val maxMemory = (Runtime.getRuntime().maxMemory() / 1024).toInt()
        val cacheSize = maxMemory / 8  // ä½¿ç”¨å¯ç”¨å†…å­˜çš„1/8ä½œä¸ºç¼“å­˜
        
        val imageCache = object : LruCache<String, Bitmap>(cacheSize) {
            override fun sizeOf(key: String, bitmap: Bitmap): Int {
                // è¿”å›Bitmapçš„å¤§å°ï¼ˆKBï¼‰
                return bitmap.byteCount / 1024
            }
            
            override fun entryRemoved(evicted: Boolean, key: String, oldValue: Bitmap, newValue: Bitmap?) {
                Log.d("Cache", "ç¼“å­˜æ¡ç›®ç§»é™¤: $key, è¢«é©±é€: $evicted")
                // å¯ä»¥åœ¨è¿™é‡Œå›æ”¶Bitmapåˆ°å¯¹è±¡æ± 
                if (evicted && !oldValue.isRecycled) {
                    bitmapPool.recycleBitmap(oldValue)
                }
            }
        }
        
        Log.d("Optimization", "åˆ›å»ºå›¾ç‰‡ç¼“å­˜ï¼Œå¤§å°: ${cacheSize}KB")
        
        // æµ‹è¯•ç¼“å­˜æ•ˆæœ
        val testImages = arrayOf("image1", "image2", "image3", "image1", "image2")  // é‡å¤è®¿é—®
        
        testImages.forEachIndexed { index, imageName ->
            val startTime = System.currentTimeMillis()
            
            var bitmap = imageCache.get(imageName)
            if (bitmap == null) {
                // ç¼“å­˜æœªå‘½ä¸­ï¼Œåˆ›å»ºæ–°å›¾ç‰‡
                bitmap = createSampleBitmap(imageName)
                imageCache.put(imageName, bitmap)
                Log.d("Cache", "ç¼“å­˜æœªå‘½ä¸­ï¼Œåˆ›å»ºå›¾ç‰‡: $imageName")
            } else {
                Log.d("Cache", "ç¼“å­˜å‘½ä¸­: $imageName")
            }
            
            val endTime = System.currentTimeMillis()
            Log.d("Cache", "ç¬¬${index + 1}æ¬¡è®¿é—®$imageNameï¼Œè€—æ—¶: ${endTime - startTime}ms")
        }
        
        // æ‰“å°ç¼“å­˜ç»Ÿè®¡
        Log.d("Cache", """
            |ç¼“å­˜ç»Ÿè®¡:
            |  å‘½ä¸­æ¬¡æ•°: ${imageCache.hitCount()}
            |  æœªå‘½ä¸­æ¬¡æ•°: ${imageCache.missCount()}
            |  å‘½ä¸­ç‡: ${imageCache.hitCount() * 100 / (imageCache.hitCount() + imageCache.missCount())}%
            |  å½“å‰å¤§å°: ${imageCache.size()}KB
        """.trimMargin())
    }
    
    private fun demonstrateBitmapOptimization() {
        Log.d("Optimization", "--- å›¾ç‰‡å†…å­˜ä¼˜åŒ– ---")
        
        // ä¼˜åŒ–1ï¼šæ­£ç¡®çš„é‡‡æ ·ç‡è®¡ç®—
        val options = BitmapFactory.Options()
        
        // é¦–å…ˆåªè·å–å›¾ç‰‡å°ºå¯¸ï¼Œä¸åŠ è½½åƒç´ æ•°æ®
        options.inJustDecodeBounds = true
        BitmapFactory.decodeResource(resources, R.drawable.sample_large_image, options)
        
        val imageWidth = options.outWidth
        val imageHeight = options.outHeight
        Log.d("Optimization", "åŸå§‹å›¾ç‰‡å°ºå¯¸: ${imageWidth}x${imageHeight}")
        
        // ç›®æ ‡æ˜¾ç¤ºå°ºå¯¸
        val targetWidth = 512
        val targetHeight = 512
        
        // è®¡ç®—åˆé€‚çš„é‡‡æ ·ç‡
        val sampleSize = calculateInSampleSize(options, targetWidth, targetHeight)
        
        // å®é™…åŠ è½½å›¾ç‰‡
        options.inJustDecodeBounds = false
        options.inSampleSize = sampleSize
        options.inPreferredConfig = Bitmap.Config.RGB_565  // ä½¿ç”¨RGB_565å‡å°‘å†…å­˜ä½¿ç”¨
        
        val optimizedBitmap = BitmapFactory.decodeResource(resources, R.drawable.sample_large_image, options)
        
        optimizedBitmap?.let { bitmap ->
            val memoryUsage = bitmap.byteCount / 1024
            Log.d("Optimization", """
                |å›¾ç‰‡ä¼˜åŒ–ç»“æœ:
                |  é‡‡æ ·ç‡: $sampleSize
                |  ä¼˜åŒ–åå°ºå¯¸: ${bitmap.width}x${bitmap.height}
                |  å†…å­˜ä½¿ç”¨: ${memoryUsage}KB
                |  é…ç½®: ${bitmap.config}
            """.trimMargin())
            
            // ä¼˜åŒ–2ï¼šä½¿ç”¨å¯¹è±¡æ± å¤ç”¨Bitmap
            val reusedBitmap = bitmapPool.getBitmap(bitmap.width, bitmap.height, bitmap.config)
            Log.d("Optimization", "ä»å¯¹è±¡æ± ${if (reusedBitmap != null) "è·å–" else "åˆ›å»º"}Bitmap")
        }
    }
    
    private fun demonstrateStringOptimization() {
        Log.d("Optimization", "--- å­—ç¬¦ä¸²æ“ä½œä¼˜åŒ– ---")
        
        val iterations = 1000
        
        // æµ‹è¯•1ï¼šStringæ‹¼æ¥ï¼ˆä½æ•ˆï¼‰
        val startTime1 = System.currentTimeMillis()
        val startMemory1 = getCurrentMemoryUsage()
        
        var result1 = ""
        repeat(iterations) {
            result1 += "Item $it, "  // æ¯æ¬¡éƒ½åˆ›å»ºæ–°çš„Stringå¯¹è±¡
        }
        
        val endTime1 = System.currentTimeMillis()
        val endMemory1 = getCurrentMemoryUsage()
        
        // æµ‹è¯•2ï¼šStringBuilderï¼ˆé«˜æ•ˆï¼‰
        val startTime2 = System.currentTimeMillis()
        val startMemory2 = getCurrentMemoryUsage()
        
        val sb = StringBuilder()
        repeat(iterations) {
            sb.append("Item $it, ")
        }
        val result2 = sb.toString()
        
        val endTime2 = System.currentTimeMillis()
        val endMemory2 = getCurrentMemoryUsage()
        
        Log.d("Optimization", """
            |å­—ç¬¦ä¸²æ“ä½œå¯¹æ¯”:
            |Stringæ‹¼æ¥:
            |  è€—æ—¶: ${endTime1 - startTime1}ms
            |  å†…å­˜å¢é•¿: ${endMemory1 - startMemory1}KB
            |
            |StringBuilder:
            |  è€—æ—¶: ${endTime2 - startTime2}ms
            |  å†…å­˜å¢é•¿: ${endMemory2 - startMemory2}KB
            |
            |æ€§èƒ½å·®å¼‚:
            |  é€Ÿåº¦æå‡: ${(endTime1 - startTime1) - (endTime2 - startTime2)}ms
            |  å†…å­˜èŠ‚çº¦: ${(endMemory1 - startMemory1) - (endMemory2 - startMemory2)}KB
        """.trimMargin())
    }
    
    // å·¥å…·æ–¹æ³•
    private fun getCurrentMemoryUsage(): Long {
        val runtime = Runtime.getRuntime()
        return (runtime.totalMemory() - runtime.freeMemory()) / 1024
    }
    
    private fun createSampleBitmap(name: String): Bitmap {
        // åˆ›å»ºç¤ºä¾‹å›¾ç‰‡
        val bitmap = Bitmap.createBitmap(256, 256, Bitmap.Config.ARGB_8888)
        val canvas = Canvas(bitmap)
        val paint = Paint().apply {
            textSize = 32f
            color = Color.WHITE
        }
        canvas.drawColor(Color.BLUE)
        canvas.drawText(name, 50f, 128f, paint)
        return bitmap
    }
    
    private fun calculateInSampleSize(options: BitmapFactory.Options, reqWidth: Int, reqHeight: Int): Int {
        val height = options.outHeight
        val width = options.outWidth
        var inSampleSize = 1
        
        if (height > reqHeight || width > reqWidth) {
            val halfHeight = height / 2
            val halfWidth = width / 2
            
            while ((halfHeight / inSampleSize) >= reqHeight && (halfWidth / inSampleSize) >= reqWidth) {
                inSampleSize *= 2
            }
        }
        
        return inSampleSize
    }
}

// é€šç”¨å¯¹è±¡æ± å®ç°
class ObjectPool<T>(private val factory: () -> T) {
    private val pool = mutableListOf<T>()
    private val maxSize = 10
    
    fun acquire(): T {
        return if (pool.isNotEmpty()) {
            pool.removeAt(pool.size - 1)
        } else {
            factory()
        }
    }
    
    fun release(obj: T) {
        if (pool.size < maxSize) {
            pool.add(obj)
        }
    }
}

// Bitmapå¯¹è±¡æ± 
class BitmapPool {
    private val pool = mutableMapOf<String, MutableList<Bitmap>>()
    
    fun getBitmap(width: Int, height: Int, config: Bitmap.Config): Bitmap? {
        val key = "${width}x${height}_$config"
        val bitmaps = pool[key]
        
        return if (bitmaps?.isNotEmpty() == true) {
            bitmaps.removeAt(bitmaps.size - 1)
        } else {
            null
        }
    }
    
    fun recycleBitmap(bitmap: Bitmap) {
        if (!bitmap.isRecycled) {
            val key = "${bitmap.width}x${bitmap.height}_${bitmap.config}"
            pool.getOrPut(key) { mutableListOf() }.add(bitmap)
        }
    }
}
```

## ğŸ“ æ€»ç»“ä¸è¿›é˜¶æŒ‡å—

é€šè¿‡è¿™äº›æ¸è¿›å¼çš„ä»£ç ç¤ºä¾‹ï¼ŒJavaå¼€å‘è€…å¯ä»¥ï¼š

1. **ç¬¬1çº§**ï¼šå»ºç«‹åŸºç¡€æ¦‚å¿µï¼Œç†è§£å †æ ˆå·®å¼‚å’ŒGCè¡Œä¸º
2. **ç¬¬2çº§**ï¼šæ·±å…¥ç†è§£å†…å­˜åˆ†é…ä½ç½®å’Œè™šæ‹Ÿå†…å­˜æ˜ å°„
3. **ç¬¬3çº§**ï¼šæŒæ¡å®é™…çš„å†…å­˜é—®é¢˜è¯Šæ–­å’Œæ€§èƒ½ä¼˜åŒ–æŠ€èƒ½

æ¯ä¸ªç¤ºä¾‹éƒ½åŒ…å«äº†è¯¦ç»†çš„éªŒè¯æ–¹æ³•å’Œè§‚å¯Ÿè¦ç‚¹ï¼Œç»“åˆMemory Profilerç­‰å·¥å…·ï¼Œå¯ä»¥è®©å­¦ä¹ è€…åœ¨å®é™…æ“ä½œä¸­æ·±å…¥ç†è§£Androidå†…å­˜ç®¡ç†æœºåˆ¶ã€‚