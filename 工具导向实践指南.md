# Androidå†…å­˜åˆ†æå·¥å…·å®è·µæŒ‡å—

## æ¦‚è¿°ï¼šä»å·¥å…·å¼€å§‹ï¼Œç†è§£å†…å­˜ç®¡ç†

ä½œä¸ºJavaå¼€å‘è€…ï¼Œæœ€ç›´æ¥çš„å­¦ä¹ æ–¹å¼å°±æ˜¯ä»ä½ æ—¥å¸¸ä½¿ç”¨çš„å·¥å…·å¼€å§‹ã€‚è¿™ä¸ªæŒ‡å—å°†å¸¦ä½ ä»Android Studio Memory Profilerå¼€å§‹ï¼Œé€æ­¥æ·±å…¥åˆ°å„ç§å†…å­˜åˆ†æå·¥å…·ï¼Œè®©ä½ åœ¨å®é™…æ“ä½œä¸­ç†è§£å†…å­˜ç®¡ç†åŸç†ã€‚

## ğŸ¯ å­¦ä¹ è·¯å¾„ï¼šå·¥å…·é©±åŠ¨çš„ç†è§£æ–¹å¼

### ç¬¬1æ­¥ï¼šAndroid Studio Memory Profilerï¼ˆå…¥é—¨çº§ï¼‰
### ç¬¬2æ­¥ï¼šå‘½ä»¤è¡Œå·¥å…·ç»„åˆï¼ˆè¿›é˜¶çº§ï¼‰
### ç¬¬3æ­¥ï¼šä¸“ä¸šå†…å­˜åˆ†æå·¥å…·ï¼ˆä¸“å®¶çº§ï¼‰

---

## ç¬¬1æ­¥ï¼šAndroid Studio Memory Profiler - ä½ çš„ç¬¬ä¸€æŠŠé’¥åŒ™

### ğŸš€ å¿«é€Ÿä¸Šæ‰‹ï¼š3åˆ†é’ŸæŒæ¡åŸºç¡€æ“ä½œ

#### 1.1 å¯åŠ¨Memory Profiler
```kotlin
// 1. åˆ›å»ºä¸€ä¸ªæµ‹è¯•Activity
class MemoryAnalysisActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_memory)
        
        // 2. è¿è¡Œåº”ç”¨å¹¶æ‰“å¼€Profiler
        // Run â†’ Profile 'app'
        // æˆ–è€… View â†’ Tool Windows â†’ Profiler
        
        performMemoryIntensiveOperations()
    }
    
    private fun performMemoryIntensiveOperations() {
        // æˆ‘ä»¬å°†è§‚å¯Ÿè¿™äº›æ“ä½œå¯¹å†…å­˜çš„å½±å“
        createManyObjects()
        loadLargeImages()
        createMemoryLeak()
    }
}
```

#### 1.2 ç†è§£Memory Profilerçš„å„ä¸ªæŒ‡æ ‡
```
Memory Profiler ç•Œé¢è§£è¯»ï¼š

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Java/Kotlin â”‚ Native â”‚ Graphics â”‚ Stack â”‚ Code â”‚ Others â”‚
â”‚      â†“           â†“        â†“         â†“      â†“       â†“     â”‚
â”‚  ARTè™šæ‹Ÿæœº    C++å†…å­˜   GPUå†…å­˜   çº¿ç¨‹æ ˆ  ä»£ç æ®µ   å…¶ä»–   â”‚
â”‚    å †å†…å­˜                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 1.3 å®é™…æ“ä½œï¼šè§‚å¯Ÿå†…å­˜åˆ†é…æ¨¡å¼
```kotlin
class MemoryPatternObserver {
    
    fun demonstrateJavaHeapAllocation() {
        // ğŸ“Š åœ¨Profilerä¸­è§‚å¯Ÿï¼šJava/Kotlinå†…å­˜å¢é•¿
        val objectList = mutableListOf<User>()
        
        repeat(1000) { index ->
            objectList.add(User("User$index", generateLargeData()))
            
            if (index % 100 == 0) {
                // æ¯åˆ›å»º100ä¸ªå¯¹è±¡ï¼Œè®°å½•ä¸€ä¸‹å½“å‰å†…å­˜çŠ¶æ€
                logMemoryState("åˆ›å»ºäº†${index}ä¸ªå¯¹è±¡")
            }
        }
        
        // ğŸ” è§‚å¯Ÿè¦ç‚¹ï¼š
        // 1. Java/Kotlin æŸ±çŠ¶å›¾é€æ¸å¢é«˜
        // 2. å¯èƒ½çœ‹åˆ°é”¯é½¿çŠ¶çš„GCå›æ”¶æ¨¡å¼
        // 3. åˆ†é…é€Ÿç‡ï¼ˆAllocation rateï¼‰æ˜¾ç¤ºå¯¹è±¡åˆ›å»ºé¢‘ç‡
    }
    
    fun demonstrateNativeHeapAllocation() {
        // ğŸ“Š åœ¨Profilerä¸­è§‚å¯Ÿï¼šNativeå†…å­˜å¢é•¿
        val bitmapList = mutableListOf<Bitmap>()
        
        repeat(20) { index ->
            // Android 8+ï¼šåƒç´ æ•°æ®å­˜åœ¨Nativeå †ä¸­
            val bitmap = Bitmap.createBitmap(1024, 1024, Bitmap.Config.ARGB_8888)
            bitmapList.add(bitmap)
            
            logMemoryState("åˆ›å»ºäº†${index + 1}ä¸ªå¤§å›¾ç‰‡")
        }
        
        // ğŸ” è§‚å¯Ÿè¦ç‚¹ï¼š
        // 1. Native æŸ±çŠ¶å›¾æ˜¾è‘—å¢é•¿
        // 2. Java/Kotlin ä»…æœ‰å°‘é‡å¢é•¿ï¼ˆBitmapå¯¹è±¡æœ¬èº«ï¼‰
        // 3. å›¾ç‰‡åƒç´ æ•°æ®ç¡®å®å­˜åœ¨Nativeå †ä¸­
    }
    
    private fun logMemoryState(operation: String) {
        val runtime = Runtime.getRuntime()
        val usedMemory = (runtime.totalMemory() - runtime.freeMemory()) / 1024 / 1024
        
        Log.d("MemoryState", "$operation - Javaå †ä½¿ç”¨: ${usedMemory}MB")
    }
}
```

### ğŸ”§ Memory Profilerçš„æ ¸å¿ƒåŠŸèƒ½è¯¦è§£

#### 1.4 Heap Dumpåˆ†æï¼šçœ‹æ¸…å†…å­˜ä¸­çš„æ¯ä¸ªå¯¹è±¡
```kotlin
class HeapDumpAnalyzer {
    
    fun createObjectsForHeapDump() {
        // åˆ›å»ºä¸€äº›æœ‰è¶£çš„å¯¹è±¡ç”¨äºåˆ†æ
        val normalObjects = Array(500) { User("Normal$it") }
        val leakedObjects = createMemoryLeak()  // æ•…æ„åˆ›å»ºå†…å­˜æ³„æ¼
        val largeObjects = Array(10) { ByteArray(1024 * 1024) }  // 10ä¸ª1MBæ•°ç»„
        
        // ğŸ’¡ æ“ä½œæ­¥éª¤ï¼š
        // 1. è¿è¡Œåˆ°è¿™é‡Œåï¼Œåœ¨Memory Profilerä¸­ç‚¹å‡»"åƒåœ¾æ¡¶"å›¾æ ‡å¼ºåˆ¶GC
        // 2. ç‚¹å‡»"Capture heap dump"æŒ‰é’®
        // 3. ç­‰å¾…ç”Ÿæˆå¿«ç…§
        
        Thread.sleep(5000)  // ç»™ä½ æ—¶é—´å»ç‚¹å‡»æŒ‰é’®
    }
    
    // ğŸ“Š Heap Dumpåˆ†æè¦ç‚¹ï¼š
    // 1. æŒ‰ç±»åæŸ¥çœ‹ï¼šæ‰¾åˆ°Userç±»ï¼ŒæŸ¥çœ‹æœ‰å¤šå°‘ä¸ªå®ä¾‹
    // 2. æŒ‰å¤§å°æ’åºï¼šæ‰¾åˆ°å å†…å­˜æœ€å¤šçš„å¯¹è±¡ç±»å‹
    // 3. æŸ¥çœ‹å¼•ç”¨é“¾ï¼šåˆ†æå¯¹è±¡è¢«è°æŒæœ‰ï¼Œä¸ºä»€ä¹ˆæ²¡è¢«GCå›æ”¶
}
```

#### 1.5 Allocation Trackingï¼šè¿½è¸ªå¯¹è±¡åˆ†é…
```kotlin
class AllocationTracker {
    
    fun demonstrateAllocationTracking() {
        // ğŸ’¡ æ“ä½œæ­¥éª¤ï¼š
        // 1. åœ¨Memory Profilerä¸­ç‚¹å‡»"Record allocations"
        // 2. æ‰§è¡Œä¸‹é¢çš„ä»£ç 
        // 3. åœæ­¢å½•åˆ¶ï¼Œåˆ†æåˆ†é…æƒ…å†µ
        
        performAllocations()
    }
    
    private fun performAllocations() {
        // åœºæ™¯1ï¼šå¤§é‡å°å¯¹è±¡åˆ†é…
        repeat(1000) {
            val user = User("User$it")
            processUser(user)
        }
        
        // åœºæ™¯2ï¼šå°‘é‡å¤§å¯¹è±¡åˆ†é…
        repeat(5) {
            val largeBuffer = ByteArray(10 * 1024 * 1024)  // 10MB
            processBuffer(largeBuffer)
        }
        
        // åœºæ™¯3ï¼šå­—ç¬¦ä¸²æ‹¼æ¥ï¼ˆå¯èƒ½äº§ç”Ÿå¾ˆå¤šä¸´æ—¶å¯¹è±¡ï¼‰
        var result = ""
        repeat(100) {
            result += "Item$it, "  // æ¯æ¬¡éƒ½åˆ›å»ºæ–°çš„Stringå¯¹è±¡
        }
        
        // ğŸ“Š åœ¨Allocation Trackingç»“æœä¸­è§‚å¯Ÿï¼š
        // 1. å“ªä¸ªæ–¹æ³•åˆ†é…äº†æœ€å¤šå†…å­˜ï¼Ÿ
        // 2. Stringå¯¹è±¡æ˜¯å¦çœŸçš„åˆ›å»ºäº†å¾ˆå¤šä¸´æ—¶å¯¹è±¡ï¼Ÿ
        // 3. ByteArrayçš„åˆ†é…æ¨¡å¼å¦‚ä½•ï¼Ÿ
    }
}
```

---

## ç¬¬2æ­¥ï¼šå‘½ä»¤è¡Œå·¥å…·ç»„åˆ - æ·±å…¥ç³»ç»Ÿå±‚é¢

### ğŸ–¥ï¸ ä½¿ç”¨ADBå‘½ä»¤æ·±å…¥åˆ†æ

#### 2.1 dumpsys meminfoï¼šç³»ç»Ÿçº§å†…å­˜åˆ†æ
```bash
# è·å–åº”ç”¨çš„è¯¦ç»†å†…å­˜ä¿¡æ¯
adb shell dumpsys meminfo com.yourapp.package

# è§£è¯»è¾“å‡ºç»“æœï¼š
```

```kotlin
// åˆ›å»ºä¸€ä¸ªå·¥å…·ç±»æ¥è§£é‡Šdumpsysè¾“å‡º
class DumpsysAnalyzer {
    
    fun explainDumpsysOutput() {
        /*
        å…¸å‹çš„dumpsys meminfoè¾“å‡ºè§£è¯»ï¼š
        
        ** MEMINFO in pid 12345 [com.yourapp] **
                           Pss  Private  Private  SwapPss     Heap     Heap     Heap
                         Total    Dirty    Clean    Dirty     Size    Alloc     Free
                        ------   ------   ------   ------   ------   ------   ------
          Java Heap:     8924     8884        0        0    20480    12345     8135
          Native Heap:   15678    15200        0        0                           
          Code:          4562        0     4562        0                           
          Stack:         1024     1024        0        0                           
          Graphics:      25600    25600        0        0                           
          Private Other: 8234     8000      234        0
          System:        2345        0     2345        0
                        ------   ------   ------   ------   ------   ------   ------
          TOTAL:        66367    58708     7141        0    20480    12345     8135
        
        ğŸ” å…³é”®æŒ‡æ ‡è§£è¯»ï¼š
        - Java Heap: ARTè™šæ‹Ÿæœºå †çš„ä½¿ç”¨æƒ…å†µ
        - Native Heap: C/C++å †ï¼ŒAndroid 8+åŒ…å«å›¾ç‰‡åƒç´ æ•°æ®
        - Graphics: GPUç›¸å…³å†…å­˜ï¼ŒåŒ…å«çº¹ç†ã€æ¸²æŸ“ç¼“å†²ç­‰
        - Stack: æ‰€æœ‰çº¿ç¨‹çš„æ ˆå†…å­˜æ€»å’Œ
        - Code: åº”ç”¨ä»£ç æ®µå ç”¨çš„å†…å­˜
        */
    }
    
    fun compareMemoryStates() {
        // ğŸ’¡ å®è·µæŠ€å·§ï¼šå¯¹æ¯”ä¸åŒçŠ¶æ€ä¸‹çš„å†…å­˜
        // 1. Appåˆšå¯åŠ¨æ—¶è®°å½•ä¸€æ¬¡
        // 2. æ‰§è¡ŒæŸä¸ªåŠŸèƒ½åå†è®°å½•ä¸€æ¬¡
        // 3. å¯¹æ¯”å·®å¼‚ï¼Œå®šä½å†…å­˜å¢é•¿æºå¤´
        
        logCommand("adb shell dumpsys meminfo com.yourapp > memory_before.txt")
        performSomeFeature()
        logCommand("adb shell dumpsys meminfo com.yourapp > memory_after.txt")
        logCommand("diff memory_before.txt memory_after.txt")
    }
}
```

#### 2.2 /proc/[pid]/mapsï¼šæŸ¥çœ‹è¿›ç¨‹å†…å­˜æ˜ å°„
```bash
# æŸ¥çœ‹è¿›ç¨‹çš„è™šæ‹Ÿå†…å­˜å¸ƒå±€
adb shell cat /proc/$(pidof com.yourapp)/maps

# ç†è§£è¾“å‡ºæ ¼å¼ï¼šåœ°å€èŒƒå›´ æƒé™ åç§» è®¾å¤‡ inode æ–‡ä»¶å
```

```kotlin
class ProcessMapsAnalyzer {
    
    fun explainProcessMaps() {
        /*
        å…¸å‹çš„/proc/[pid]/mapsè¾“å‡ºè§£è¯»ï¼š
        
        12c00000-52c00000 rw-p 00000000 00:00 0          [anon:libc_malloc]
        ^^^^^^^^ ^^^^^^^^ ^^^^ ^^^^^^^^ ^^^^^ ^          ^^^^^^^^^^^^^^^
        èµ·å§‹åœ°å€  ç»“æŸåœ°å€  æƒé™   åç§»    è®¾å¤‡  inode         æè¿°
        
        é‡è¦çš„å†…å­˜åŒºåŸŸæ ‡è¯†ï¼š
        - [heap]: è¿›ç¨‹ä¸»å †æ®µ
        - [anon:libc_malloc]: Nativeå †åˆ†é…çš„åŒ¿åå†…å­˜
        - [anon:dalvik-main space]: ARTè™šæ‹Ÿæœºä¸»å †ç©ºé—´
        - [stack]: ä¸»çº¿ç¨‹æ ˆ
        - libxxx.so: å„ç§åŠ¨æ€åº“
        
        ğŸ” è¿™å¸®åŠ©ä½ ç†è§£ï¼š
        1. ä½ çš„Appå®é™…å ç”¨äº†å“ªäº›è™šæ‹Ÿåœ°å€ç©ºé—´
        2. ARTå †åœ¨è¿›ç¨‹åœ°å€ç©ºé—´ä¸­çš„ä½ç½®
        3. Nativeåº“åŠ è½½çš„åœ°å€èŒƒå›´
        */
    }
    
    fun analyzeHeapGrowth() {
        // ğŸ’¡ å®è·µï¼šè§‚å¯Ÿå †ç©ºé—´çš„åŠ¨æ€å˜åŒ–
        logCommand("è§‚å¯Ÿå †ç©ºé—´å˜åŒ–ï¼š")
        logCommand("while true; do")
        logCommand("  adb shell cat /proc/$(pidof com.yourapp)/maps | grep heap")
        logCommand("  sleep 2")
        logCommand("done")
        
        // åŒæ—¶åœ¨åº”ç”¨ä¸­æŒç»­åˆ†é…å†…å­˜ï¼Œè§‚å¯Ÿå †è¾¹ç•Œçš„å˜åŒ–
    }
}
```

#### 2.3 å®æ—¶å†…å­˜ç›‘æ§è„šæœ¬
```bash
#!/bin/bash
# memory_monitor.sh - å®æ—¶ç›‘æ§åº”ç”¨å†…å­˜ä½¿ç”¨

PACKAGE="com.yourapp.package"
INTERVAL=2

echo "ç›‘æ§ $PACKAGE çš„å†…å­˜ä½¿ç”¨æƒ…å†µ..."
echo "æ—¶é—´æˆ³,Javaå †,Nativeå †,Graphics,æ€»å†…å­˜"

while true; do
    TIMESTAMP=$(date +"%H:%M:%S")
    
    # è·å–å†…å­˜ä¿¡æ¯
    MEMINFO=$(adb shell dumpsys meminfo $PACKAGE | grep -A 20 "MEMINFO")
    
    JAVA_HEAP=$(echo "$MEMINFO" | grep "Java Heap:" | awk '{print $3}')
    NATIVE_HEAP=$(echo "$MEMINFO" | grep "Native Heap:" | awk '{print $3}')
    GRAPHICS=$(echo "$MEMINFO" | grep "Graphics:" | awk '{print $3}')
    TOTAL=$(echo "$MEMINFO" | grep "TOTAL:" | awk '{print $2}')
    
    echo "$TIMESTAMP,$JAVA_HEAP,$NATIVE_HEAP,$GRAPHICS,$TOTAL"
    
    sleep $INTERVAL
done
```

---

## ç¬¬3æ­¥ï¼šä¸“ä¸šå†…å­˜åˆ†æå·¥å…· - ä¸“å®¶çº§è¯Šæ–­

### ğŸ”¬ LeakCanaryï¼šè‡ªåŠ¨å†…å­˜æ³„æ¼æ£€æµ‹

#### 3.1 é›†æˆå’Œä½¿ç”¨LeakCanary
```kotlin
// åœ¨build.gradleä¸­æ·»åŠ 
dependencies {
    debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.12'
}

class LeakCanaryDemo : AppCompatActivity() {
    
    companion object {
        // æ•…æ„åˆ›å»ºä¸€ä¸ªé™æ€å¼•ç”¨ï¼Œæ¼”ç¤ºLeakCanaryçš„æ£€æµ‹èƒ½åŠ›
        private var leakedActivity: Activity? = null
    }
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // ğŸ“Š LeakCanaryä¼šè‡ªåŠ¨æ£€æµ‹ä»¥ä¸‹ç±»å‹çš„æ³„æ¼ï¼š
        demonstrateActivityLeak()
        demonstrateViewLeak()
        demonstrateHandlerLeak()
    }
    
    private fun demonstrateActivityLeak() {
        // ğŸ” è¿™ä¼šè¢«LeakCanaryæ£€æµ‹åˆ°
        leakedActivity = this  // Activityè¢«é™æ€å¼•ç”¨æŒæœ‰ï¼Œæ— æ³•è¢«GC
        
        // LeakCanaryä¼šåœ¨é€šçŸ¥æ æ˜¾ç¤ºå†…å­˜æ³„æ¼æŠ¥å‘Š
        // æŠ¥å‘Šå†…å®¹åŒ…æ‹¬ï¼š
        // 1. æ³„æ¼çš„å¯¹è±¡ç±»å‹
        // 2. å¼•ç”¨é“¾è·¯å¾„
        // 3. æ³„æ¼çš„æ ¹æœ¬åŸå› 
    }
    
    private fun demonstrateViewLeak() {
        val customView = CustomView(this)
        
        // ğŸ” å¦‚æœCustomViewæŒæœ‰Contextçš„å¼ºå¼•ç”¨ï¼Œä¹Ÿä¼šè¢«æ£€æµ‹åˆ°
        ViewLeakHolder.holdView(customView)
    }
    
    private fun demonstrateHandlerLeak() {
        val handler = Handler(Looper.getMainLooper())
        
        // ğŸ” å»¶è¿Ÿæ¶ˆæ¯æŒæœ‰Activityå¼•ç”¨ï¼ŒLeakCanaryä¼šæ£€æµ‹åˆ°
        handler.postDelayed({
            // è¿™ä¸ªlambdaæŒæœ‰Activityçš„éšå¼å¼•ç”¨
            updateUI()
        }, 30000)  // 30ç§’åæ‰§è¡Œï¼Œè¶³å¤ŸActivityè¢«é”€æ¯
    }
}

object ViewLeakHolder {
    private val views = mutableListOf<View>()
    fun holdView(view: View) { views.add(view) }
}
```

#### 3.2 è‡ªå®šä¹‰å†…å­˜æ³„æ¼æ£€æµ‹è§„åˆ™
```kotlin
class CustomLeakDetection : Application() {
    
    override fun onCreate() {
        super.onCreate()
        
        // è‡ªå®šä¹‰LeakCanaryçš„æ£€æµ‹è§„åˆ™
        LeakCanary.config = LeakCanary.config.copy(
            // æ£€æµ‹è‡ªå®šä¹‰å¯¹è±¡çš„æ³„æ¼
            objectInspectors = LeakCanary.config.objectInspectors + listOf(
                UserObjectInspector()
            ),
            
            // è‡ªå®šä¹‰æ³„æ¼ç›‘å¬å™¨
            onHeapAnalyzedListener = { heapAnalysis ->
                when (heapAnalysis) {
                    is HeapAnalysisSuccess -> {
                        Log.d("LeakCanary", "å‘ç°${heapAnalysis.allLeaks.size}ä¸ªå†…å­˜æ³„æ¼")
                        
                        heapAnalysis.allLeaks.forEach { leak ->
                            Log.e("Leak", "æ³„æ¼å¯¹è±¡: ${leak.className}")
                            Log.e("Leak", "å¼•ç”¨è·¯å¾„: ${leak.leakTrace}")
                        }
                    }
                    is HeapAnalysisFailure -> {
                        Log.e("LeakCanary", "åˆ†æå¤±è´¥: ${heapAnalysis.exception}")
                    }
                }
            }
        )
    }
}

class UserObjectInspector : ObjectInspector {
    override fun inspect(reporter: ObjectReporter) {
        // æ£€æŸ¥è‡ªå®šä¹‰å¯¹è±¡Useræ˜¯å¦è¢«æ­£ç¡®é‡Šæ”¾
        if (reporter.heapObject.asInstance?.instanceClassName == "User") {
            // æ·»åŠ è‡ªå®šä¹‰çš„æ£€æŸ¥é€»è¾‘
            reporter.notLeakingReasons += "Userå¯¹è±¡åº”è¯¥è¢«åŠæ—¶é‡Šæ”¾"
        }
    }
}
```

### ğŸ”§ MAT (Memory Analyzer Tool)ï¼šæ·±åº¦å†…å­˜åˆ†æ

#### 3.3 å¯¼å‡ºå’Œåˆ†æhprofæ–‡ä»¶
```kotlin
class MATAnalysis {
    
    fun generateHprofForMAT() {
        // ğŸ’¡ ç”ŸæˆMATå¯åˆ†æçš„å†…å­˜å¿«ç…§
        // 1. åˆ›å»ºå¤æ‚çš„å†…å­˜ç»“æ„
        createComplexObjectGraph()
        
        // 2. ä½¿ç”¨adbå¯¼å‡ºhprofæ–‡ä»¶
        // adb shell am dumpheap com.yourapp /sdcard/memory.hprof
        // adb pull /sdcard/memory.hprof
        
        // 3. è½¬æ¢æ ¼å¼ä¾›MATä½¿ç”¨
        // hprof-conv memory.hprof memory-mat.hprof
        
        // 4. ç”¨MATæ‰“å¼€memory-mat.hprofè¿›è¡Œåˆ†æ
    }
    
    private fun createComplexObjectGraph() {
        // åˆ›å»ºä¸€ä¸ªå¤æ‚çš„å¯¹è±¡å¼•ç”¨å…³ç³»ï¼Œæ–¹ä¾¿åœ¨MATä¸­åˆ†æ
        val users = mutableListOf<User>()
        val companies = mutableListOf<Company>()
        
        // åˆ›å»ºç›¸äº’å¼•ç”¨çš„å¯¹è±¡ç½‘ç»œ
        repeat(100) { i ->
            val user = User("User$i")
            val company = Company("Company${i / 10}")
            
            user.company = company
            company.employees.add(user)
            
            users.add(user)
            if (i % 10 == 0) companies.add(company)
        }
        
        // æ•…æ„åˆ›å»ºä¸€äº›å¾ªç¯å¼•ç”¨
        users.forEach { user ->
            user.friends = users.filter { it != user }.take(5).toMutableList()
        }
        
        // ğŸ’¡ åœ¨MATä¸­ä½ å¯ä»¥ï¼š
        // 1. æŸ¥çœ‹Dominator Treeï¼šæ‰¾åˆ°å å†…å­˜æœ€å¤šçš„å¯¹è±¡
        // 2. æŸ¥çœ‹å¯¹è±¡çš„å¼•ç”¨å…³ç³»å›¾
        // 3. ä½¿ç”¨OQLæŸ¥è¯¢ç‰¹å®šå¯¹è±¡
        // 4. åˆ†æå†…å­˜æ³„æ¼çš„å¼•ç”¨é“¾
    }
}

data class User(val name: String) {
    var company: Company? = null
    var friends: MutableList<User> = mutableListOf()
}

data class Company(val name: String) {
    val employees: MutableList<User> = mutableListOf()
}
```

### ğŸ“± å®æˆ˜æ¡ˆä¾‹ï¼šå®Œæ•´çš„å†…å­˜é—®é¢˜è¯Šæ–­æµç¨‹

#### 3.4 ç»¼åˆè¯Šæ–­å®ä¾‹
```kotlin
class MemoryDiagnosticWorkflow : AppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // ğŸ¯ å®Œæ•´çš„å†…å­˜è¯Šæ–­å·¥ä½œæµç¨‹
        performDiagnosticWorkflow()
    }
    
    private fun performDiagnosticWorkflow() {
        // ç¬¬1æ­¥ï¼šå»ºç«‹åŸºçº¿
        recordBaselineMemory()
        
        // ç¬¬2æ­¥ï¼šæ‰§è¡Œå¯èƒ½æœ‰é—®é¢˜çš„æ“ä½œ
        performSuspiciousOperations()
        
        // ç¬¬3æ­¥ï¼šä½¿ç”¨å¤šç§å·¥å…·åˆ†æ
        analyzeWithMultipleTools()
        
        // ç¬¬4æ­¥ï¼šéªŒè¯ä¿®å¤æ•ˆæœ
        verifyFixes()
    }
    
    private fun recordBaselineMemory() {
        Log.d("Diagnostic", "=== å»ºç«‹å†…å­˜åŸºçº¿ ===")
        
        // å¼ºåˆ¶GCï¼Œè·å¾—å¹²å‡€çš„åŸºçº¿
        System.gc()
        Thread.sleep(1000)
        
        val runtime = Runtime.getRuntime()
        val baseline = MemorySnapshot(
            javaHeap = runtime.totalMemory() - runtime.freeMemory(),
            timestamp = System.currentTimeMillis()
        )
        
        Log.d("Diagnostic", "åŸºçº¿Javaå †: ${baseline.javaHeap / 1024}KB")
        
        // ğŸ’¡ åŒæ—¶ä½¿ç”¨å‘½ä»¤è¡Œè®°å½•è¯¦ç»†ä¿¡æ¯
        // adb shell dumpsys meminfo com.yourapp > baseline_memory.txt
    }
    
    private fun performSuspiciousOperations() {
        Log.d("Diagnostic", "=== æ‰§è¡Œå¯ç–‘æ“ä½œ ===")
        
        // æ¨¡æ‹Ÿå¸¸è§çš„å†…å­˜é—®é¢˜åœºæ™¯
        repeat(10) {
            // åœºæ™¯1ï¼šå¤§é‡å›¾ç‰‡åŠ è½½
            loadManyImages()
            
            // åœºæ™¯2ï¼šåˆ›å»ºå¤§é‡å¯¹è±¡
            createManyObjects()
            
            // åœºæ™¯3ï¼šå¯èƒ½çš„å†…å­˜æ³„æ¼
            potentialMemoryLeak()
            
            logCurrentMemoryState("æ“ä½œ ${it + 1} å®Œæˆ")
        }
    }
    
    private fun analyzeWithMultipleTools() {
        Log.d("Diagnostic", "=== å¤šå·¥å…·åˆ†æ ===")
        
        // å·¥å…·1ï¼šAndroid Studio Memory Profiler
        // ğŸ’¡ æ‰‹åŠ¨æ“ä½œï¼šCapture heap dump
        Log.d("Diagnostic", "è¯·åœ¨Memory Profilerä¸­æ•è·heap dump")
        Thread.sleep(5000)
        
        // å·¥å…·2ï¼šdumpsys meminfoåˆ†æ
        Log.d("Diagnostic", "è¯·æ‰§è¡Œ: adb shell dumpsys meminfo $packageName")
        
        // å·¥å…·3ï¼šLeakCanaryè‡ªåŠ¨åˆ†æ
        // ï¼ˆå¦‚æœé›†æˆäº†LeakCanaryï¼Œå®ƒä¼šè‡ªåŠ¨æ£€æµ‹æ³„æ¼ï¼‰
        
        // å·¥å…·4ï¼šè‡ªå®šä¹‰å†…å­˜è¿½è¸ª
        trackCustomMemoryMetrics()
    }
    
    private fun trackCustomMemoryMetrics() {
        val memInfo = Debug.MemoryInfo()
        Debug.getMemoryInfo(memInfo)
        
        val metrics = """
            |è‡ªå®šä¹‰å†…å­˜æŒ‡æ ‡:
            |Javaå †: ${memInfo.dalvikHeap}KB
            |Nativeå †: ${memInfo.nativeHeap}KB  
            |Graphics: ${memInfo.graphics}KB
            |æ€»PSS: ${memInfo.totalPss}KB
        """.trimMargin()
        
        Log.d("Diagnostic", metrics)
    }
    
    private fun verifyFixes() {
        Log.d("Diagnostic", "=== éªŒè¯ä¿®å¤æ•ˆæœ ===")
        
        // åº”ç”¨å†…å­˜ä¼˜åŒ–åï¼Œé‡æ–°æµ‹è¯•
        // 1. å¯¹è±¡æ± å¤ç”¨
        // 2. åŠæ—¶é‡Šæ”¾èµ„æº
        // 3. å¼±å¼•ç”¨ä½¿ç”¨
        // 4. ç”Ÿå‘½å‘¨æœŸç®¡ç†
        
        performOptimizedOperations()
        logCurrentMemoryState("ä¼˜åŒ–å")
    }
    
    // è¾…åŠ©æ–¹æ³•
    private fun loadManyImages() {
        repeat(5) {
            val bitmap = BitmapFactory.decodeResource(resources, R.drawable.sample_image)
            // æ•…æ„ä¸ç«‹å³å›æ”¶ï¼Œæ¨¡æ‹Ÿå†…å­˜ç§¯ç´¯
            processImage(bitmap)
        }
    }
    
    private fun createManyObjects() {
        val objects = Array(1000) { User("User$it") }
        // åˆ›å»ºåä¸ç«‹å³é‡Šæ”¾å¼•ç”¨
    }
    
    private fun potentialMemoryLeak() {
        // åˆ›å»ºå¯èƒ½çš„å†…å­˜æ³„æ¼åœºæ™¯
        val handler = Handler(Looper.getMainLooper())
        handler.postDelayed({
            // è¿™ä¸ªrunnableæŒæœ‰Activityå¼•ç”¨
            Log.d("Leak", "å»¶è¿Ÿæ‰§è¡Œçš„æ“ä½œ")
        }, 60000)  // 1åˆ†é’Ÿåæ‰§è¡Œ
    }
    
    private fun logCurrentMemoryState(tag: String) {
        val runtime = Runtime.getRuntime()
        val used = (runtime.totalMemory() - runtime.freeMemory()) / 1024
        Log.d("MemoryState", "$tag - Javaå †ä½¿ç”¨: ${used}KB")
    }
}

data class MemorySnapshot(
    val javaHeap: Long,
    val timestamp: Long
)
```

## ğŸ“ æ€»ç»“ï¼šå·¥å…·é€‰æ‹©æŒ‡å—

### æ ¹æ®é—®é¢˜ç±»å‹é€‰æ‹©åˆé€‚çš„å·¥å…·

```kotlin
class ToolSelectionGuide {
    
    fun selectToolForProblem(problemType: MemoryProblem): List<String> {
        return when (problemType) {
            MemoryProblem.SLOW_PERFORMANCE -> listOf(
                "Android Studio Memory Profiler - æŸ¥çœ‹GCé¢‘ç‡",
                "dumpsys meminfo - åˆ†æå†…å­˜åˆ†å¸ƒ",
                "Systrace - åˆ†æGCå¯¹æ€§èƒ½çš„å½±å“"
            )
            
            MemoryProblem.OUT_OF_MEMORY -> listOf(
                "Memory Profiler Heap Dump - æŸ¥çœ‹å¤§å¯¹è±¡",
                "MAT - æ·±åº¦åˆ†æå¯¹è±¡å¼•ç”¨å…³ç³»", 
                "dumpsys meminfo - ç¡®å®šå†…å­˜ç±»å‹"
            )
            
            MemoryProblem.MEMORY_LEAK -> listOf(
                "LeakCanary - è‡ªåŠ¨æ£€æµ‹å¸¸è§æ³„æ¼",
                "Memory Profiler - æ‰‹åŠ¨åˆ†æå¼•ç”¨é“¾",
                "MAT - æ·±åº¦åˆ†æå¤æ‚æ³„æ¼"
            )
            
            MemoryProblem.BITMAP_ISSUES -> listOf(
                "Memory Profiler - è§‚å¯ŸNativeå †å˜åŒ–",
                "GPU Memory Profiler - åˆ†æçº¹ç†å†…å­˜",
                "è‡ªå®šä¹‰ç›‘æ§ - è¿½è¸ªBitmapç”Ÿå‘½å‘¨æœŸ"
            )
        }
    }
}

enum class MemoryProblem {
    SLOW_PERFORMANCE,    // æ€§èƒ½ç¼“æ…¢
    OUT_OF_MEMORY,       // å†…å­˜æº¢å‡º
    MEMORY_LEAK,         // å†…å­˜æ³„æ¼
    BITMAP_ISSUES        // å›¾ç‰‡å†…å­˜é—®é¢˜
}
```

é€šè¿‡è¿™ä¸ªå·¥å…·å¯¼å‘çš„å­¦ä¹ æ–¹æ³•ï¼Œä½ å°†ä»å®é™…æ“ä½œä¸­æ·±å…¥ç†è§£Androidå†…å­˜ç®¡ç†ï¼Œæ¯ä¸ªå·¥å…·éƒ½ä¼šå¸®ä½ ä»ä¸åŒè§’åº¦è§‚å¯Ÿå’Œåˆ†æå†…å­˜é—®é¢˜ã€‚